#!/usr/bin/env bun

import { readFileSync, writeFileSync, existsSync, mkdirSync, statSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

// Get current directory equivalent to Python's __file__
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

function readBinaryFile(filePath: string): Uint8Array {
   // """Read binary file and return as Uint8Array"""
    return new Uint8Array(readFileSync(filePath));
}

function bytesToCppArray(data: Uint8Array, variableName: string): string {
   // """Convert binary data to C++ byte array format"""
    const bytes = Array.from(data).map(byte => `0x${byte.toString(16).padStart(2, '0')}`);
    const chunks: string[] = [];
    
    // Split into lines of 16 bytes each for readability
    for (let i = 0; i < bytes.length; i += 16) {
        const chunk = bytes.slice(i, i + 16).join(', ');
        chunks.push(`    ${chunk}`);
    }
    
    return `const unsigned char ${variableName}[] = {\n${chunks.join(',\n')}\n};\nconst unsigned int ${variableName}_size = ${data.length};`;
}

function generateHeaderFile(outputPath: string, componentName: string, functionPrefix: string): void {
    //"""Generate header file for webapp or editor"""
    const headerContent = `#pragma once

// Auto-generated binary resources from mikobench/dist/${componentName}/index.html
// Do not edit this file manually

// Function to get the HTML content as a C-string
const char* Get${functionPrefix}HTML();

// Function to get the size of the HTML content
unsigned int Get${functionPrefix}HTMLSize();
`;
    
    writeFileSync(outputPath, headerContent, 'utf-8');
}

function generateCppFile(htmlData: Uint8Array, outputPath: string, headerName: string, componentName: string, functionPrefix: string, variableName: string): void {
    //"""Generate cpp implementation file for webapp or editor"""
    const cppArray = bytesToCppArray(htmlData, variableName);
    
    const cppContent = `#include "${headerName}"

// Auto-generated binary resources from mikobench/dist/${componentName}/index.html
// Do not edit this file manually

${cppArray}

const char* Get${functionPrefix}HTML() {
    return reinterpret_cast<const char*>(${variableName});
}

unsigned int Get${functionPrefix}HTMLSize() {
    return ${variableName}_size;
}
`;
    
    writeFileSync(outputPath, cppContent, 'utf-8');
}

function main(): void {
    // Get script directory
    const scriptDir = __dirname;
    const projectRoot = join(scriptDir, '..', '..');
    
    // Input file paths
    const rootuiHtmlFile = join(projectRoot, 'mikobench', 'dist', 'rootui', 'index.html');
    const editorHtmlFile = join(projectRoot, 'mikobench', 'dist', 'editor', 'index.html');
    
    // Output file paths
    const appDir = join(projectRoot, 'app', 'resources');
    const webappCppFile = join(appDir, 'webapp.cpp');
    const webappHppFile = join(appDir, 'webapp.hpp');
    const editorCppFile = join(appDir, 'editor.cpp');
    const editorHppFile = join(appDir, 'editor.hpp');
    
    // Check if input files exist
    if (!existsSync(rootuiHtmlFile)) {
        console.error(`Error: Input file not found: ${rootuiHtmlFile}`);
        console.error("Please build the mikobench rootui project first using 'bun run build'");
        process.exit(1);
    }
    
    if (!existsSync(editorHtmlFile)) {
        console.error(`Error: Input file not found: ${editorHtmlFile}`);
        console.error("Please build the mikobench editor project first using 'bun run build'");
        process.exit(1);
    }
    
    // Create app directory if it doesn't exist
    if (!existsSync(appDir)) {
        mkdirSync(appDir, { recursive: true });
    }
    
    // Process rootUI files
    console.log(`Reading rootUI HTML file: ${rootuiHtmlFile}`);
    const rootuiHtmlData = readBinaryFile(rootuiHtmlFile);
    
    console.log(`Generating rootUI header file: ${webappHppFile}`);
    generateHeaderFile(webappHppFile, 'rootui', 'WebApp');
    
    console.log(`Generating rootUI implementation file: ${webappCppFile}`);
    generateCppFile(rootuiHtmlData, webappCppFile, 'webapp.hpp', 'rootui', 'WebApp', 'webapp_html');
    
    // Process editor files
    console.log(`Reading editor HTML file: ${editorHtmlFile}`);
    const editorHtmlData = readBinaryFile(editorHtmlFile);
    
    console.log(`Generating editor header file: ${editorHppFile}`);
    generateHeaderFile(editorHppFile, 'editor', 'Editor');
    
    console.log(`Generating editor implementation file: ${editorCppFile}`);
    generateCppFile(editorHtmlData, editorCppFile, 'editor.hpp', 'editor', 'Editor', 'editor_html');
    
    console.log('\nConversion completed successfully!');
    console.log('Generated files:');
    console.log(`  - ${webappHppFile} (${statSync(webappHppFile).size} bytes)`);
    console.log(`  - ${webappCppFile} (${statSync(webappCppFile).size} bytes)`);
    console.log(`  - ${editorHppFile} (${statSync(editorHppFile).size} bytes)`);
    console.log(`  - ${editorCppFile} (${statSync(editorCppFile).size} bytes)`);
    console.log(`\nRootUI HTML data size: ${rootuiHtmlData.length} bytes`);
    console.log(`Editor HTML data size: ${editorHtmlData.length} bytes`);
    
    console.log('\nTo use in your C++ code:');
    console.log('For rootUI:');
    console.log('  #include "webapp.hpp"');
    console.log('  const char* html = GetWebAppHTML();');
    console.log('  unsigned int size = GetWebAppHTMLSize();');
    console.log('\nFor editor:');
    console.log('  #include "editor.hpp"');
    console.log('  const char* html = GetEditorHTML();');
    console.log('  unsigned int size = GetEditorHTMLSize();');
}

if (import.meta.main) {
    main();
}