diff --git a/app/client/client.cpp b/app/client/client.cpp
index b867637..2e27164 100644
--- a/app/client/client.cpp
+++ b/app/client/client.cpp
@@ -42,7 +42,14 @@ SDL3Window::SDL3Window()
     , window_start_x_(0)
     , window_start_y_(0)
     , dx11_renderer_(nullptr)
-    , dx11_enabled_(false) {
+    , dx11_enabled_(false)
+    , editor_texture_(nullptr)
+    , editor_browser_(nullptr)
+    , editor_enabled_(false)
+    , cef_buffer_width_(0)
+    , cef_buffer_height_(0)
+    , editor_buffer_width_(0)
+    , editor_buffer_height_(0) {
 }
 
 SDL3Window::~SDL3Window() {
@@ -95,7 +102,7 @@ bool SDL3Window::Initialize(int width, int height) {
         Logger::LogMessage("SDL3 renderer creation failed: " + std::string(SDL_GetError()));
         SDL_DestroyWindow(window_);
         SDL_Quit();
-        return false;
+        return true;
     }
 
     // Create texture for CEF rendering
@@ -105,7 +112,7 @@ bool SDL3Window::Initialize(int width, int height) {
         SDL_DestroyRenderer(renderer_);
         SDL_DestroyWindow(window_);
         SDL_Quit();
-        return false;
+        return true;
     }
     // IMPORTANT: Avoid blending (OSR may deliver alpha=0 everywhere)
     SDL_SetTextureBlendMode(texture_, SDL_BLENDMODE_NONE);
@@ -141,6 +148,9 @@ void SDL3Window::Shutdown() {
         dx11_enabled_ = false;
     }
     
+    // Destroy editor sublayer first
+    DestroyEditorSublayer();
+    
     if (texture_) {
         SDL_DestroyTexture(texture_);
         texture_ = nullptr;
@@ -298,7 +308,21 @@ bool SDL3Window::HandleEvent(const SDL_Event& event) {
                 }
             }
             
-            // Notify CEF browser of size change
+            // Recreate editor texture with new size if editor is enabled
+            if (editor_enabled_ && editor_texture_) {
+                SDL_DestroyTexture(editor_texture_);
+                editor_texture_ = SDL_CreateTexture(renderer_, SDL_PIXELFORMAT_BGRA32, 
+                                                  SDL_TEXTUREACCESS_STREAMING, 
+                                                  editor_rect_.width, editor_rect_.height);
+                if (!editor_texture_) {
+                    Logger::LogMessage("Resize: Failed to recreate editor texture - " + std::string(SDL_GetError()));
+                } else {
+                    SDL_SetTextureBlendMode(editor_texture_, SDL_BLENDMODE_BLEND);
+                    Logger::LogMessage("Resize: Editor texture recreated successfully");
+                }
+            }
+            
+            // Notify CEF browsers about size change
             if (client_) {
                 auto browser = client_->GetFirstBrowser();
                 if (browser) {
@@ -306,6 +330,9 @@ bool SDL3Window::HandleEvent(const SDL_Event& event) {
                     Logger::LogMessage("Resize: Notified CEF browser of size change");
                 }
             }
+            if (editor_browser_) {
+                editor_browser_->GetHost()->WasResized();
+            }
             return true;
 
         case SDL_EVENT_MOUSE_BUTTON_DOWN:
@@ -338,33 +365,86 @@ void SDL3Window::SendMouseEvent(const SDL_Event& event) {
     auto browser = client_->GetFirstBrowser();
     if (!browser) return;
 
-    CefMouseEvent mouse_event;
-    mouse_event.x = event.button.x;
-    mouse_event.y = event.button.y;
-    mouse_event.modifiers = 0; // TODO: Handle modifiers
-
-    last_mouse_x_ = event.button.x;
-    last_mouse_y_ = event.button.y;
-
+    int x = 0, y = 0;
+    
+    // Get mouse position based on event type
     switch (event.type) {
+        case SDL_EVENT_MOUSE_BUTTON_DOWN:
+        case SDL_EVENT_MOUSE_BUTTON_UP:
+            x = static_cast<int>(event.button.x);
+            y = static_cast<int>(event.button.y);
+            break;
         case SDL_EVENT_MOUSE_MOTION:
-            browser->GetHost()->SendMouseMoveEvent(mouse_event, false);
+            x = static_cast<int>(event.motion.x);
+            y = static_cast<int>(event.motion.y);
             break;
-
-        case SDL_EVENT_MOUSE_BUTTON_DOWN:
-        case SDL_EVENT_MOUSE_BUTTON_UP: {
-            CefBrowserHost::MouseButtonType button_type = MBT_LEFT;
-            if (event.button.button == SDL_BUTTON_RIGHT) {
-                button_type = MBT_RIGHT;
-            } else if (event.button.button == SDL_BUTTON_MIDDLE) {
-                button_type = MBT_MIDDLE;
+        default:
+            return;
+    }
+    
+    // Check if mouse is over editor sublayer
+    if (editor_enabled_ && 
+        x >= editor_rect_.x && x < editor_rect_.x + editor_rect_.width &&
+        y >= editor_rect_.y && y < editor_rect_.y + editor_rect_.height) {
+        
+        // Send event to editor browser with adjusted coordinates
+        if (editor_browser_) {
+            int editor_x = x - editor_rect_.x;
+            int editor_y = y - editor_rect_.y;
+            
+            CefMouseEvent mouse_event;
+            mouse_event.x = editor_x;
+            mouse_event.y = editor_y;
+            mouse_event.modifiers = 0;
+            
+            switch (event.type) {
+                case SDL_EVENT_MOUSE_BUTTON_DOWN:
+                case SDL_EVENT_MOUSE_BUTTON_UP: {
+                    CefBrowserHost::MouseButtonType button_type = MBT_LEFT;
+                    if (event.button.button == SDL_BUTTON_RIGHT) button_type = MBT_RIGHT;
+                    else if (event.button.button == SDL_BUTTON_MIDDLE) button_type = MBT_MIDDLE;
+                    
+                    bool mouse_up = (event.type == SDL_EVENT_MOUSE_BUTTON_UP);
+                    int click_count = event.button.clicks;
+                    
+                    editor_browser_->GetHost()->SendMouseClickEvent(mouse_event, button_type, mouse_up, click_count);
+                    break;
+                }
+                case SDL_EVENT_MOUSE_MOTION:
+                    editor_browser_->GetHost()->SendMouseMoveEvent(mouse_event, false);
+                    break;
             }
+        }
+    } else {
+        // Send to main browser
+        CefMouseEvent mouse_event;
+        mouse_event.x = x;
+        mouse_event.y = y;
+        mouse_event.modifiers = 0;
 
-            bool mouse_up = (event.type == SDL_EVENT_MOUSE_BUTTON_UP);
-            int click_count = event.button.clicks;
-            
-            browser->GetHost()->SendMouseClickEvent(mouse_event, button_type, mouse_up, click_count);
-            break;
+        last_mouse_x_ = x;
+        last_mouse_y_ = y;
+
+        switch (event.type) {
+            case SDL_EVENT_MOUSE_MOTION:
+                browser->GetHost()->SendMouseMoveEvent(mouse_event, false);
+                break;
+
+            case SDL_EVENT_MOUSE_BUTTON_DOWN:
+            case SDL_EVENT_MOUSE_BUTTON_UP: {
+                CefBrowserHost::MouseButtonType button_type = MBT_LEFT;
+                if (event.button.button == SDL_BUTTON_RIGHT) {
+                    button_type = MBT_RIGHT;
+                } else if (event.button.button == SDL_BUTTON_MIDDLE) {
+                    button_type = MBT_MIDDLE;
+                }
+
+                bool mouse_up = (event.type == SDL_EVENT_MOUSE_BUTTON_UP);
+                int click_count = event.button.clicks;
+                
+                browser->GetHost()->SendMouseClickEvent(mouse_event, button_type, mouse_up, click_count);
+                break;
+            }
         }
     }
 }
@@ -375,18 +455,41 @@ void SDL3Window::SendKeyEvent(const SDL_Event& event) {
     auto browser = client_->GetFirstBrowser();
     if (!browser) return;
 
-    CefKeyEvent key_event;
-    key_event.windows_key_code = event.key.key;
-    key_event.native_key_code = event.key.scancode;
-    key_event.modifiers = 0; // TODO: Handle modifiers properly
+    // Check if editor sublayer has focus (mouse is over it)
+    if (editor_enabled_ && 
+        last_mouse_x_ >= editor_rect_.x && last_mouse_x_ < editor_rect_.x + editor_rect_.width &&
+        last_mouse_y_ >= editor_rect_.y && last_mouse_y_ < editor_rect_.y + editor_rect_.height) {
+        
+        // Send key event to editor browser
+        if (editor_browser_) {
+            CefKeyEvent key_event;
+            key_event.windows_key_code = event.key.key;
+            key_event.native_key_code = event.key.scancode;
+            key_event.modifiers = 0; // TODO: Handle modifiers properly
+
+            if (event.type == SDL_EVENT_KEY_DOWN) {
+                key_event.type = KEYEVENT_KEYDOWN;
+            } else {
+                key_event.type = KEYEVENT_KEYUP;
+            }
 
-    if (event.type == SDL_EVENT_KEY_DOWN) {
-        key_event.type = KEYEVENT_KEYDOWN;
+            editor_browser_->GetHost()->SendKeyEvent(key_event);
+        }
     } else {
-        key_event.type = KEYEVENT_KEYUP;
-    }
+        // Send to main browser
+        CefKeyEvent key_event;
+        key_event.windows_key_code = event.key.key;
+        key_event.native_key_code = event.key.scancode;
+        key_event.modifiers = 0; // TODO: Handle modifiers properly
+
+        if (event.type == SDL_EVENT_KEY_DOWN) {
+            key_event.type = KEYEVENT_KEYDOWN;
+        } else {
+            key_event.type = KEYEVENT_KEYUP;
+        }
 
-    browser->GetHost()->SendKeyEvent(key_event);
+        browser->GetHost()->SendKeyEvent(key_event);
+    }
 }
 
 void SDL3Window::SendScrollEvent(const SDL_Event& event) {
@@ -395,15 +498,38 @@ void SDL3Window::SendScrollEvent(const SDL_Event& event) {
     auto browser = client_->GetFirstBrowser();
     if (!browser) return;
 
-    CefMouseEvent mouse_event;
-    mouse_event.x = last_mouse_x_;
-    mouse_event.y = last_mouse_y_;
-    mouse_event.modifiers = 0;
+    // Check if mouse is over editor sublayer
+    if (editor_enabled_ && 
+        last_mouse_x_ >= editor_rect_.x && last_mouse_x_ < editor_rect_.x + editor_rect_.width &&
+        last_mouse_y_ >= editor_rect_.y && last_mouse_y_ < editor_rect_.y + editor_rect_.height) {
+        
+        // Send scroll event to editor browser with adjusted coordinates
+        if (editor_browser_) {
+            int editor_x = last_mouse_x_ - editor_rect_.x;
+            int editor_y = last_mouse_y_ - editor_rect_.y;
+            
+            CefMouseEvent mouse_event;
+            mouse_event.x = editor_x;
+            mouse_event.y = editor_y;
+            mouse_event.modifiers = 0;
+            
+            int delta_x = 0;
+            int delta_y = static_cast<int>(event.wheel.y * 120); // Standard wheel delta
+            
+            editor_browser_->GetHost()->SendMouseWheelEvent(mouse_event, delta_x, delta_y);
+        }
+    } else {
+        // Send to main browser
+        CefMouseEvent mouse_event;
+        mouse_event.x = last_mouse_x_;
+        mouse_event.y = last_mouse_y_;
+        mouse_event.modifiers = 0;
 
-    int delta_x = 0;
-    int delta_y = static_cast<int>(event.wheel.y * 120); // Standard wheel delta
+        int delta_x = 0;
+        int delta_y = static_cast<int>(event.wheel.y * 120); // Standard wheel delta
 
-    browser->GetHost()->SendMouseWheelEvent(mouse_event, delta_x, delta_y);
+        browser->GetHost()->SendMouseWheelEvent(mouse_event, delta_x, delta_y);
+    }
 }
 
 void SDL3Window::UpdateTexture(const void* buffer, int width, int height) {
@@ -411,12 +537,30 @@ void SDL3Window::UpdateTexture(const void* buffer, int width, int height) {
         Logger::LogMessage("UpdateTexture: Buffer is null");
         return;
     }
+    
+    if (width <= 0 || height <= 0) {
+        Logger::LogMessage("UpdateTexture: Invalid dimensions - " + std::to_string(width) + "x" + std::to_string(height));
+        return;
+    }
 
     Logger::LogMessage("UpdateTexture: Received buffer " + std::to_string(width) + "x" + std::to_string(height));
 
+    // CRITICAL: Copy CEF buffer immediately - CEF sends temporary pointer!
+    const size_t bufferSize = width * height * 4; // BGRA32 format
+    if (cef_buffer_width_ != width || cef_buffer_height_ != height) {
+        cef_buffer_.resize(bufferSize);
+        cef_buffer_width_ = width;
+        cef_buffer_height_ = height;
+        Logger::LogMessage("UpdateTexture: Resized buffer to " + std::to_string(width) + "x" + std::to_string(height));
+    }
+    
+    // Copy CEF data immediately before it becomes invalid
+    std::memcpy(cef_buffer_.data(), buffer, bufferSize);
+    Logger::LogMessage("UpdateTexture: Copied CEF buffer data (" + std::to_string(bufferSize) + " bytes)");
+
     // Try DX11 texture update first if available and enabled
     if (dx11_enabled_ && dx11_renderer_) {
-        if (dx11_renderer_->UpdateTexture(buffer, width, height)) {
+        if (dx11_renderer_->UpdateTexture(cef_buffer_.data(), width, height)) {
             Logger::LogMessage("UpdateTexture: DX11 texture update succeeded");
             return;
         } else {
@@ -460,6 +604,7 @@ void SDL3Window::UpdateTexture(const void* buffer, int width, int height) {
             Logger::LogMessage("UpdateTexture: Destroyed old texture");
         }
         
+        // CRITICAL: Use BGRA32 format to match CEF OSR output
         texture_ = SDL_CreateTexture(renderer_, SDL_PIXELFORMAT_BGRA32, SDL_TEXTUREACCESS_STREAMING, width, height);
         
         if (!texture_) {
@@ -469,126 +614,46 @@ void SDL3Window::UpdateTexture(const void* buffer, int width, int height) {
         // IMPORTANT: Avoid blending with alpha=0 content from OSR
         SDL_SetTextureBlendMode(texture_, SDL_BLENDMODE_NONE);
 
-        Logger::LogMessage("UpdateTexture: Successfully created texture " + std::to_string(width) + "x" + std::to_string(height));
+        Logger::LogMessage("UpdateTexture: Successfully created BGRA32 texture " + std::to_string(width) + "x" + std::to_string(height));
     }
 
-    // 🔑 Copy CEF buffer → texture
+    // Update texture with our copied buffer data
     void* pixels = nullptr;
     int pitch = 0;
-    if (SDL_LockTexture(texture_, nullptr, &pixels, &pitch)) {
+    
+    // Lock the entire texture for writing
+    if (SDL_LockTexture(texture_, nullptr, &pixels, &pitch) == 0) {
         Logger::LogMessage("UpdateTexture: Locked texture, pitch=" + std::to_string(pitch) + ", expected=" + std::to_string(width * 4));
         
-        const uint8_t* src = static_cast<const uint8_t*>(buffer);
-        const int rowBytes = width * 4; // BGRA32
-        for (int y = 0; y < height; y++) {
-            std::memcpy(static_cast<uint8_t*>(pixels) + y * pitch,
-                        src + y * rowBytes,
-                        rowBytes);
-        }
-        SDL_UnlockTexture(texture_);
-        Logger::LogMessage("UpdateTexture: Successfully updated texture with buffer data");
-    } else {
-        Logger::LogMessage("UpdateTexture: Failed to lock texture - " + std::string(SDL_GetError()));
-    }
-}
-
-void SDL3Window::Render() {
-    // Try DX11 rendering first if available and enabled
-    if (dx11_enabled_ && dx11_renderer_) {
-        if (dx11_renderer_->Render()) {
-            // DX11 rendering succeeded
+        if (!pixels) {
+            Logger::LogMessage("UpdateTexture: Locked texture but pixels pointer is null");
+            SDL_UnlockTexture(texture_);
             return;
-        } else {
-            Logger::LogMessage("Render: DX11 rendering failed, falling back to SDL3");
-            // Fall back to SDL3 rendering
         }
-    }
-
-    // SDL3 fallback rendering
-    if (!renderer_) {
-        Logger::LogMessage("Render: Renderer is null");
-        return;
-    }
-    
-    if (!texture_) {
-        Logger::LogMessage("Render: Texture is null");
-        return;
-    }
-
-    Logger::LogMessage("Render: Using SDL3 rendering pipeline");
-
-    // Clear the renderer
-    SDL_SetRenderDrawColor(renderer_, 0, 0, 0, 255);
-    if (!SDL_RenderClear(renderer_)) {
-        Logger::LogMessage("Render: Failed to clear renderer - " + std::string(SDL_GetError()));
-        return;
-    }
-    
-    // Render the texture (cover whole window)
-    if (SDL_RenderTexture(renderer_, texture_, nullptr, nullptr) != 0) {
-        Logger::LogMessage("Render: Failed to render texture - " + std::string(SDL_GetError()));
         
-        // Try alternative rendering approach
-        SDL_FRect destRect = {0, 0, (float)width_, (float)height_};
-        if (SDL_RenderTexture(renderer_, texture_, nullptr, &destRect) != 0) {
-            Logger::LogMessage("Render: Alternative render also failed - " + std::string(SDL_GetError()));
-        } else {
-            Logger::LogMessage("Render: Alternative render succeeded");
+        const uint8_t* src = cef_buffer_.data(); // Use our copied buffer instead of temporary CEF pointer
+        uint8_t* dst = static_cast<uint8_t*>(pixels);
+        const int rowBytes = width * 4; // BGRA32 format
+        
+        // Validate pitch is reasonable
+        if (pitch < rowBytes) {
+            Logger::LogMessage("UpdateTexture: Invalid pitch " + std::to_string(pitch) + " < " + std::to_string(rowBytes));
+            SDL_UnlockTexture(texture_);
+            return;
         }
-    } else {
-        Logger::LogMessage("Render: Successfully rendered texture");
-    }
-    
-    // Present the rendered frame
-    SDL_RenderPresent(renderer_);
-    Logger::LogMessage("Render: Presented frame");
-}
-
-// OSRRenderHandler implementation
-OSRRenderHandler::OSRRenderHandler(SDL3Window* window) : window_(window) {
-}
-
-void OSRRenderHandler::GetViewRect(CefRefPtr<CefBrowser> browser, CefRect& rect) {
-    if (window_) {
-        rect.x = 0;
-        rect.y = 0;
-        rect.width = 1200; // Default width
-        rect.height = 800; // Default height
         
-        // Get actual window size
-        if (window_->GetSDLWindow()) {
-            int w, h;
-            SDL_GetWindowSize(window_->GetSDLWindow(), &w, &h);
-            rect.width = w;
-            rect.height = h;
-            Logger::LogMessage("GetViewRect: " + std::to_string(w) + "x" + std::to_string(h));
-        } else {
-            Logger::LogMessage("GetViewRect: Using default size " + std::to_string(rect.width) + "x" + std::to_string(rect.height));
+        // Copy row by row to handle different pitch values
+        for (int y = 0; y < height; y++) {
+            const uint8_t* srcRow = src + y * rowBytes;
+            uint8_t* dstRow = dst + y * pitch;
+            std::memcpy(dstRow, srcRow, rowBytes);
         }
+        
+        SDL_UnlockTexture(texture_);
+        Logger::LogMessage("UpdateTexture: Successfully updated texture with copied buffer data");
     } else {
-        Logger::LogMessage("GetViewRect: Window is null, using default 1200x800");
-        rect.x = 0;
-        rect.y = 0;
-        rect.width = 1200;
-        rect.height = 800;
-    }
-}
-
-void OSRRenderHandler::OnPaint(CefRefPtr<CefBrowser> browser,
-                              PaintElementType type,
-                              const RectList& dirtyRects,
-                              const void* buffer,
-                              int width,
-                              int height) {
-    if (type != PET_VIEW || !window_ || !buffer) {
-        Logger::LogMessage("OnPaint: Invalid parameters - type=" + std::to_string(type) + ", window=" + (window_ ? "valid" : "null") + ", buffer=" + (buffer ? "valid" : "null"));
-        return;
+        Logger::LogMessage("UpdateTexture: Failed to lock texture - " + std::string(SDL_GetError()));
     }
-    
-    Logger::LogMessage("OnPaint: Received paint event " + std::to_string(width) + "x" + std::to_string(height) + ", dirty rects=" + std::to_string(dirtyRects.size()));
-
-    // UpdateTexture now handles create/recreate + copy
-    window_->UpdateTexture(buffer, width, height);
 }
 
 bool SimpleClient::OnCursorChange(CefRefPtr<CefBrowser> browser,
@@ -654,16 +719,30 @@ void OSRRenderHandler::UpdateDragCursor(CefRefPtr<CefBrowser> browser,
 
 // SimpleClient implementation
 SimpleClient::SimpleClient(SDL3Window* window) : window_(window) {
+    if (!window) {
+        Logger::LogMessage("Warning: SimpleClient created with null window pointer");
+    }
+    
     // Create message router for JavaScript-to-C++ communication
     CefMessageRouterConfig config;
     message_router_ = CefMessageRouterBrowserSide::Create(config);
-    message_router_->AddHandler(this, false);
+    if (message_router_) {
+        message_router_->AddHandler(this, false);
+    } else {
+        Logger::LogMessage("Failed to create CEF message router");
+    }
     
     // Create the binary resource provider for miko:// protocol
     resource_provider_ = new BinaryResourceProvider();
+    if (!resource_provider_) {
+        Logger::LogMessage("Failed to create binary resource provider");
+    }
     
     // Create OSR render handler
     render_handler_ = new OSRRenderHandler(window_);
+    if (!render_handler_) {
+        Logger::LogMessage("Failed to create OSR render handler");
+    }
     
     // Set client reference in window
     if (window_) {
@@ -1014,10 +1093,12 @@ void SimpleClient::OnBeforeClose(CefRefPtr<CefBrowser> browser) {
     
     // Remove from the list of existing browsers
     BrowserList::iterator bit = browser_list_.begin();
-    for (; bit != browser_list_.end(); ++bit) {
+    while (bit != browser_list_.end()) {
         if ((*bit)->IsSame(browser)) {
-            browser_list_.erase(bit);
+            bit = browser_list_.erase(bit);  // erase returns iterator to next element
             break;
+        } else {
+            ++bit;
         }
     }
     
@@ -1213,3 +1294,296 @@ void SimpleClient::SendMouseWheelEvent(int x, int y, int delta_x, int delta_y) {
     }
 }
 
+// Editor sublayer management methods
+bool SDL3Window::CreateEditorSublayer(int x, int y, int width, int height) {
+    if (editor_enabled_) {
+        Logger::LogMessage("Editor sublayer already exists");
+        return false;
+    }
+    
+    // Validate parameters
+    if (width <= 0 || height <= 0) {
+        Logger::LogMessage("Invalid editor dimensions - width: " + std::to_string(width) + ", height: " + std::to_string(height));
+        return false;
+    }
+    
+    if (!hwnd_ || !client_) {
+        Logger::LogMessage("Invalid window handle or client for editor creation");
+        return false;
+    }
+    
+    // Set editor rectangle
+    editor_rect_.x = x;
+    editor_rect_.y = y;
+    editor_rect_.width = width;
+    editor_rect_.height = height;
+    
+    // Create editor texture
+    editor_texture_ = SDL_CreateTexture(renderer_, SDL_PIXELFORMAT_BGRA32, 
+                                      SDL_TEXTUREACCESS_STREAMING, width, height);
+    if (!editor_texture_) {
+        Logger::LogMessage("Failed to create editor texture - " + std::string(SDL_GetError()));
+        return false;
+    }
+    SDL_SetTextureBlendMode(editor_texture_, SDL_BLENDMODE_BLEND);
+    
+    // Create CEF browser for editor
+    CefWindowInfo window_info;
+    window_info.SetAsWindowless(hwnd_);
+    
+    CefBrowserSettings browser_settings;
+    browser_settings.windowless_frame_rate = 60;
+    
+    Logger::LogMessage("Creating editor browser with URL: miko://app/editor.html");
+    
+    // Create browser with editor URL
+    editor_browser_ = CefBrowserHost::CreateBrowserSync(
+        window_info, client_, "miko://app/editor.html", browser_settings, nullptr, nullptr);
+    
+    if (!editor_browser_) {
+        Logger::LogMessage("Failed to create editor browser");
+        SDL_DestroyTexture(editor_texture_);
+        editor_texture_ = nullptr;
+        return false;
+    }
+    
+    editor_enabled_ = true;
+    Logger::LogMessage("Editor sublayer created successfully at " + 
+                      std::to_string(x) + "," + std::to_string(y) + " " +
+                      std::to_string(width) + "x" + std::to_string(height));
+    return true;
+}
+
+void SDL3Window::DestroyEditorSublayer() {
+    if (!editor_enabled_) return;
+    
+    if (editor_browser_) {
+        editor_browser_->GetHost()->CloseBrowser(true);
+        editor_browser_ = nullptr;
+    }
+    
+    if (editor_texture_) {
+        SDL_DestroyTexture(editor_texture_);
+        editor_texture_ = nullptr;
+    }
+    
+    editor_enabled_ = false;
+    Logger::LogMessage("Editor sublayer destroyed");
+}
+
+void SDL3Window::UpdateEditorRect(int x, int y, int width, int height) {
+    if (!editor_enabled_) return;
+    
+    editor_rect_.x = x;
+    editor_rect_.y = y;
+    editor_rect_.width = width;
+    editor_rect_.height = height;
+    
+    // Recreate texture with new size
+    if (editor_texture_) {
+        SDL_DestroyTexture(editor_texture_);
+        editor_texture_ = SDL_CreateTexture(renderer_, SDL_PIXELFORMAT_BGRA32, 
+                                          SDL_TEXTUREACCESS_STREAMING, width, height);
+        if (editor_texture_) {
+            SDL_SetTextureBlendMode(editor_texture_, SDL_BLENDMODE_BLEND);
+        }
+    }
+    
+    // Notify browser of size change
+    if (editor_browser_) {
+        editor_browser_->GetHost()->WasResized();
+    }
+    
+    Logger::LogMessage("Editor rect updated to " + 
+                      std::to_string(x) + "," + std::to_string(y) + " " +
+                      std::to_string(width) + "x" + std::to_string(height));
+}
+
+void SDL3Window::UpdateEditorTexture(const void* buffer, int width, int height) {
+    if (!editor_texture_ || !renderer_ || !editor_enabled_ || !buffer) {
+        return;
+    }
+    
+    if (width <= 0 || height <= 0) {
+        Logger::LogMessage("UpdateEditorTexture: Invalid dimensions - width: " + std::to_string(width) + ", height: " + std::to_string(height));
+        return;
+    }
+
+    void* pixels;
+    int pitch;
+    
+    if (SDL_LockTexture(editor_texture_, nullptr, &pixels, &pitch) != 0) {
+        Logger::LogMessage("UpdateEditorTexture: Failed to lock texture - " + std::string(SDL_GetError()));
+        return;
+    }
+
+    // Copy buffer to editor texture
+    const uint8_t* src = static_cast<const uint8_t*>(buffer);
+    uint8_t* dst = static_cast<uint8_t*>(pixels);
+    
+    int bytes_per_pixel = 4; // BGRA32
+    int src_pitch = width * bytes_per_pixel;
+    
+    for (int y = 0; y < height; ++y) {
+        memcpy(dst + y * pitch, src + y * src_pitch, src_pitch);
+    }
+
+    SDL_UnlockTexture(editor_texture_);
+}
+
+void SDL3Window::Render() {
+    // Try DX11 rendering first if available and enabled
+    if (dx11_enabled_ && dx11_renderer_) {
+        if (dx11_renderer_->Render()) {
+            // DX11 rendering succeeded
+            return;
+        } else {
+            Logger::LogMessage("Render: DX11 rendering failed, falling back to SDL3");
+            // Fall back to SDL3 rendering
+        }
+    }
+
+    // SDL3 fallback rendering
+    if (!renderer_) {
+        Logger::LogMessage("Render: Renderer is null");
+        return;
+    }
+    
+    if (!texture_) {
+        Logger::LogMessage("Render: Texture is null");
+        return;
+    }
+
+    Logger::LogMessage("Render: Using SDL3 rendering pipeline");
+
+    // Clear the renderer
+    SDL_SetRenderDrawColor(renderer_, 0, 0, 0, 255);
+    if (SDL_RenderClear(renderer_) != 0) {
+        Logger::LogMessage("Render: Failed to clear renderer - " + std::string(SDL_GetError()));
+        return;
+    }
+    
+    // Render the texture (cover whole window)
+    if (SDL_RenderTexture(renderer_, texture_, nullptr, nullptr) != 0) {
+        Logger::LogMessage("Render: Failed to render texture - " + std::string(SDL_GetError()));
+        
+        // Try alternative rendering approach
+        SDL_FRect destRect = {0, 0, (float)width_, (float)height_};
+        if (SDL_RenderTexture(renderer_, texture_, nullptr, &destRect) != 0) {
+            Logger::LogMessage("Render: Alternative render also failed - " + std::string(SDL_GetError()));
+        } else {
+            Logger::LogMessage("Render: Alternative render succeeded");
+        }
+    } else {
+        Logger::LogMessage("Render: Successfully rendered texture");
+    }
+    
+    // Render editor sublayer if enabled
+    if (editor_enabled_ && editor_texture_) {
+        SDL_FRect editor_dst = {
+            static_cast<float>(editor_rect_.x),
+            static_cast<float>(editor_rect_.y),
+            static_cast<float>(editor_rect_.width),
+            static_cast<float>(editor_rect_.height)
+        };
+        SDL_RenderTexture(renderer_, editor_texture_, nullptr, &editor_dst);
+    }
+    
+    // Present the rendered frame
+    SDL_RenderPresent(renderer_);
+    Logger::LogMessage("Render: Presented frame");
+}
+
+// OSRRenderHandler implementation
+OSRRenderHandler::OSRRenderHandler(SDL3Window* window) : window_(window) {
+}
+
+void OSRRenderHandler::GetViewRect(CefRefPtr<CefBrowser> browser, CefRect& rect) {
+    if (window_) {
+        // Check if this is the editor browser
+        if (window_->GetEditorBrowser() && browser->IsSame(window_->GetEditorBrowser())) {
+            // Return editor sublayer dimensions
+            rect = window_->GetEditorRect();
+        } else {
+            // Main browser gets full window dimensions
+            rect.x = 0;
+            rect.y = 0;
+            rect.width = 1200; // Default width
+            rect.height = 800; // Default height
+            
+            // Get actual window size
+            if (window_->GetSDLWindow()) {
+                int w, h;
+                SDL_GetWindowSize(window_->GetSDLWindow(), &w, &h);
+                rect.width = w;
+                rect.height = h;
+                Logger::LogMessage("GetViewRect: " + std::to_string(w) + "x" + std::to_string(h));
+            } else {
+                Logger::LogMessage("GetViewRect: Using default size " + std::to_string(rect.width) + "x" + std::to_string(rect.height));
+            }
+        }
+    } else {
+        Logger::LogMessage("GetViewRect: Window is null, using default 1200x800");
+        rect.x = 0;
+        rect.y = 0;
+        rect.width = 1200;
+        rect.height = 800;
+    }
+}
+
+// --- REPLACE WHOLE FUNCTION ---
+void OSRRenderHandler::OnPaint(CefRefPtr<CefBrowser> browser,
+                               PaintElementType type,
+                               const RectList& dirtyRects,
+                               const void* buffer,
+                               int width,
+                               int height) {
+    if (type != PET_VIEW || !window_ || !buffer || !browser) {
+        return;
+    }
+    if (width <= 0 || height <= 0) {
+        return;
+    }
+
+    // ถ้าเป็น editor browser → อัปเดต editor texture
+    if (window_->GetEditorBrowser() && browser->IsSame(window_->GetEditorBrowser())) {
+        // ขนาด frame ของ editor ต้องตรงกับ editor_rect เสมอ
+        const auto r = window_->GetEditorRect();
+        if (r.width != width || r.height != height) {
+            // แจ้ง resize ให้เรา recreate texture แล้วให้ CEF รู้ตัว
+            window_->UpdateEditorRect(r.x, r.y, width, height);
+            if (window_->GetEditorBrowser())
+                window_->GetEditorBrowser()->GetHost()->WasResized();
+        }
+        window_->UpdateEditorTexture(buffer, width, height);
+        return;
+    }
+
+    // ไม่ใช่ editor ⇒ main browser
+    // ถ้า window size เปลี่ยน ให้ recreate main texture ภายใน UpdateTexture
+    window_->UpdateTexture(buffer, width, height);
+}
+
+
+// void OSRRenderHandler::OnPaint(CefRefPtr<CefBrowser> browser,
+//                               PaintElementType type,
+//                               const RectList& dirtyRects,
+//                               const void* buffer,
+//                               int width,
+//                               int height) {
+//     if (type != PET_VIEW || !window_ || !buffer || !browser) {
+//         Logger::LogMessage("OnPaint: Invalid parameters - type=" + std::to_string(type) + 
+//                           ", window=" + (window_ ? "valid" : "null") + 
+//                           ", buffer=" + (buffer ? "valid" : "null") +
+//                           ", browser=" + (browser ? "valid" : "null"));
+//         return;
+//     }
+    
+//     if (width <= 0 || height <= 0) {
+//         Logger::LogMessage("OnPaint: Invalid dimensions - " + std::to_string(width) + "x" + std::to_string(height));
+//         return;
+//     }
+    
+//     Logger::LogMessage("OnPaint: Received paint event " + std::to_string(width) + "x" + std::to_string(height) + ", dirty rects=" + std::to_string(dirtyRects.size()));
+
+// }
\ No newline at end of file
diff --git a/app/client/client.hpp b/app/client/client.hpp
index 2a7f504..c1d5aee 100644
--- a/app/client/client.hpp
+++ b/app/client/client.hpp
@@ -61,7 +61,15 @@ public:
     void Restore();
     void Close();
     
-    // Rounded corners using dwmapi
+    // Editor sublayer management
+    bool CreateEditorSublayer(int x, int y, int width, int height);
+    void DestroyEditorSublayer();
+    void UpdateEditorRect(int x, int y, int width, int height);
+    bool IsEditorEnabled() const { return editor_enabled_; }
+    CefRefPtr<CefBrowser> GetEditorBrowser() const { return editor_browser_; }
+    const CefRect& GetEditorRect() const { return editor_rect_; }
+    
+    // Window styling
     void ApplyRoundedCorners();
     void SetBorderless(bool borderless);
     
@@ -78,6 +86,7 @@ public:
     
     // CEF OSR integration
     void UpdateTexture(const void* buffer, int width, int height);
+    void UpdateEditorTexture(const void* buffer, int width, int height);
     void SetClient(CefRefPtr<SimpleClient> client) { client_ = client; }
     
     // DX11 Renderer integration
@@ -126,11 +135,25 @@ private:
     std::unique_ptr<DX11Renderer> dx11_renderer_;
     bool dx11_enabled_;
     
+    // Editor sublayer support
+    SDL_Texture* editor_texture_;
+    CefRefPtr<CefBrowser> editor_browser_;
+    bool editor_enabled_;
+    CefRect editor_rect_;  // Position and size of editor within main window
+    
+    // CEF buffer storage - copy CEF data immediately since it's temporary
+    std::vector<uint8_t> cef_buffer_;
+    std::vector<uint8_t> editor_cef_buffer_;
+    int cef_buffer_width_;
+    int cef_buffer_height_;
+    int editor_buffer_width_;
+    int editor_buffer_height_;
+    
     void InitializeDwmApi();
     void UpdateWindowStyle();
 };
 
-// CEF OSR Render Handler
+// CEF OSR Render Handler with sublayer support
 class OSRRenderHandler : public CefRenderHandler {
 public:
     OSRRenderHandler(SDL3Window* window);
diff --git a/app/main.cpp b/app/main.cpp
index 1406c40..4609440 100644
--- a/app/main.cpp
+++ b/app/main.cpp
@@ -207,6 +207,9 @@ int WINAPI WinMain(HINSTANCE hInstance,
     settings.windowless_rendering_enabled = true;
     settings.multi_threaded_message_loop = false; // We'll use our own message loop
     
+    // Enable remote debugging
+    settings.remote_debugging_port = 9222;
+    
 #ifdef _WIN32
     CefString(&settings.cache_path) = cachePath.wstring();
     CefString(&settings.browser_subprocess_path) = helperPath.wstring();
@@ -265,14 +268,31 @@ int WINAPI WinMain(HINSTANCE hInstance,
     
     // Configure browser settings
     CefBrowserSettings browser_settings;
-    browser_settings.windowless_frame_rate = 0; // 60 FPS for smooth rendering
+    browser_settings.windowless_frame_rate = 60; // 60 FPS for smooth rendering
     
     // Configure window info for off-screen rendering
     CefWindowInfo window_info;
-    window_info.SetAsWindowless(g_sdl_window->GetHWND());
+    HWND hwnd = g_sdl_window->GetHWND();
+    if (!hwnd) {
+        Logger::LogMessage("Failed to get SDL window HWND");
+        CefShutdown();
+        return 1;
+    }
+    
+    window_info.SetAsWindowless(hwnd);
+    
+    // Validate startup URL
+    std::string startup_url = AppConfig::GetStartupUrl();
+    if (startup_url.empty()) {
+        Logger::LogMessage("Startup URL is empty");
+        CefShutdown();
+        return 1;
+    }
+    
+    Logger::LogMessage("Creating CEF browser with URL: " + startup_url);
     
     // Create the browser synchronously to prevent race conditions
-    CefRefPtr<CefBrowser> browser = CefBrowserHost::CreateBrowserSync(window_info, g_client, AppConfig::GetStartupUrl(), browser_settings, nullptr, nullptr);
+    CefRefPtr<CefBrowser> browser = CefBrowserHost::CreateBrowserSync(window_info, g_client, startup_url, browser_settings, nullptr, nullptr);
     
     if (!browser) {
         Logger::LogMessage("Failed to create CEF browser");
@@ -282,6 +302,24 @@ int WINAPI WinMain(HINSTANCE hInstance,
     
     Logger::LogMessage("CEF browser created successfully");
 
+    // Create editor sublayer in the red border area (based on the screenshot)
+    // The red border appears to be in the right portion of the window
+    // Temporarily disable editor sublayer to isolate the main browser issue
+    /*
+    int editor_x = 800;  // Start at 800px from left
+    int editor_y = 50;   // Start 50px from top (below title bar)
+    int editor_width = 350;  // 350px wide
+    int editor_height = 700; // 700px tall
+    
+    if (g_sdl_window->CreateEditorSublayer(editor_x, editor_y, editor_width, editor_height)) {
+        Logger::LogMessage("Editor sublayer created successfully");
+    } else {
+        Logger::LogMessage("Failed to create editor sublayer");
+    }
+    */
+    
+    Logger::LogMessage("Skipping editor sublayer creation for debugging");
+
     // Main message loop
     while (!g_is_closing) {
         // Handle SDL events
diff --git a/app/renderer/dx11_renderer.cpp b/app/renderer/dx11_renderer.cpp
index 0efcce1..c084b33 100644
--- a/app/renderer/dx11_renderer.cpp
+++ b/app/renderer/dx11_renderer.cpp
@@ -502,10 +502,30 @@ bool DX11Renderer::CreateTextureFromBuffer(const void* buffer, int width, int he
 }
 
 bool DX11Renderer::UpdateTexture(const void* buffer, int width, int height) {
-    if (!cefTexture_ || !buffer) {
+    if (!buffer) {
         return false;
     }
     
+    // Create texture if it doesn't exist or dimensions changed
+    if (!cefTexture_) {
+        Logger::LogMessage("DX11Renderer: Creating CEF texture " + std::to_string(width) + "x" + std::to_string(height));
+        if (!CreateCEFTexture(width, height)) {
+            LogError("Failed to create CEF texture");
+            return false;
+        }
+    } else {
+        // Check if texture dimensions match
+        D3D11_TEXTURE2D_DESC desc;
+        cefTexture_->GetDesc(&desc);
+        if (desc.Width != static_cast<UINT>(width) || desc.Height != static_cast<UINT>(height)) {
+            Logger::LogMessage("DX11Renderer: Recreating CEF texture from " + std::to_string(desc.Width) + "x" + std::to_string(desc.Height) + " to " + std::to_string(width) + "x" + std::to_string(height));
+            if (!CreateCEFTexture(width, height)) {
+                LogError("Failed to recreate CEF texture");
+                return false;
+            }
+        }
+    }
+    
     D3D11_MAPPED_SUBRESOURCE mappedResource;
     HRESULT hr = context_->Map(cefTexture_.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
     if (FAILED(hr)) {
@@ -522,6 +542,7 @@ bool DX11Renderer::UpdateTexture(const void* buffer, int width, int height) {
     }
     
     context_->Unmap(cefTexture_.Get(), 0);
+    Logger::LogMessage("DX11Renderer: Successfully updated texture " + std::to_string(width) + "x" + std::to_string(height));
     return true;
 }
 
diff --git a/app/utils/config.hpp b/app/utils/config.hpp
index 79aaf21..17f41d4 100644
--- a/app/utils/config.hpp
+++ b/app/utils/config.hpp
@@ -72,7 +72,8 @@ public:
     
     static std::string GetStartupUrl() {
         if (IsDebugMode()) {
-            return "http://localhost:5173";
+            // return "http://localhost:5173";
+            return "miko://app/index.html";
         } else {
             // Use custom scheme for embedded resources
             return "miko://app/index.html";
