diff --git a/app/client/client.cpp b/app/client/client.cpp
index 4a81f27..abf5d8f 100644
--- a/app/client/client.cpp
+++ b/app/client/client.cpp
@@ -2,6 +2,7 @@
 #include "../utils/config.hpp"
 #include "../utils/logger.hpp"
 #include "../internal/simpleipc.hpp"
+#include "../resources/resourceutil.hpp"
 #include "include/wrapper/cef_helpers.h"
 #include "include/cef_app.h"
 #include <SDL3/SDL.h>
@@ -27,8 +28,8 @@ SDL3Window::SDL3Window()
     , texture_(nullptr)
     , hwnd_(nullptr)
     , client_(nullptr)
-    , width_(1200)
-    , height_(800)
+    , width_(DEFAULT_WINDOW_WIDTH)
+, height_(DEFAULT_WINDOW_HEIGHT)
     , minimized_(false)
     , maximized_(false)
     , should_close_(false)
@@ -43,7 +44,15 @@ SDL3Window::SDL3Window()
     , window_start_y_(0)
     , dx11_renderer_(nullptr)
     , dx11_enabled_(false)
-    , dpi_scale_(1.0f) {
+    , dpi_scale_(1.0f)
+    , menu_overlay_visible_(false)
+    , menu_overlay_x_(0)
+    , menu_overlay_y_(0)
+    , editor_enabled_(false)
+    , editor_rect_({0, 0, 0, 0})
+    , editor_browser_(nullptr)
+    , editor_texture_(nullptr)
+    , editor_texture_locked_(false) {
 }
 
 SDL3Window::~SDL3Window() {
@@ -127,6 +136,10 @@ void SDL3Window::Shutdown() {
         dx11_enabled_ = false;
     }
     
+    if (editor_texture_) {
+        SDL_DestroyTexture(editor_texture_);
+        editor_texture_ = nullptr;
+    }
     if (texture_) {
         SDL_DestroyTexture(texture_);
         texture_ = nullptr;
@@ -339,7 +352,14 @@ bool SDL3Window::HandleEvent(const SDL_Event& event) {
             if (HandleWindowDragging(event)) {
                 return true;
             }
-            SendMouseEvent(event);
+            // Only send to CEF if the event wasn't consumed by dragging
+            try {
+                SendMouseEvent(event);
+            } catch (const std::exception& ex) {
+                Logger::LogMessage("HandleEvent: Exception in SendMouseEvent - " + std::string(ex.what()));
+            } catch (...) {
+                Logger::LogMessage("HandleEvent: Unknown exception in SendMouseEvent");
+            }
             return true;
 
         case SDL_EVENT_MOUSE_WHEEL:
@@ -357,39 +377,69 @@ bool SDL3Window::HandleEvent(const SDL_Event& event) {
 }
 
 void SDL3Window::SendMouseEvent(const SDL_Event& event) {
-    if (!client_) return;
+    if (!client_) {
+        Logger::LogMessage("SendMouseEvent: Client is null");
+        return;
+    }
 
     auto browser = client_->GetFirstBrowser();
-    if (!browser) return;
+    if (!browser) {
+        Logger::LogMessage("SendMouseEvent: Browser is null");
+        return;
+    }
+
+    auto host = browser->GetHost();
+    if (!host) {
+        Logger::LogMessage("SendMouseEvent: Browser host is null");
+        return;
+    }
 
     CefMouseEvent mouse_event;
     mouse_event.x = event.button.x;
     mouse_event.y = event.button.y;
     mouse_event.modifiers = 0; // TODO: Handle modifiers
 
+    // Validate coordinates are within reasonable bounds
+    if (mouse_event.x < 0 || mouse_event.y < 0 || 
+        mouse_event.x > width_ || mouse_event.y > height_) {
+        Logger::LogMessage("SendMouseEvent: Mouse coordinates out of bounds (" + 
+                          std::to_string(mouse_event.x) + ", " + std::to_string(mouse_event.y) + ")");
+        return;
+    }
+
     last_mouse_x_ = event.button.x;
     last_mouse_y_ = event.button.y;
 
-    switch (event.type) {
-        case SDL_EVENT_MOUSE_MOTION:
-            browser->GetHost()->SendMouseMoveEvent(mouse_event, false);
-            break;
+    try {
+        switch (event.type) {
+            case SDL_EVENT_MOUSE_MOTION:
+                host->SendMouseMoveEvent(mouse_event, false);
+                break;
 
-        case SDL_EVENT_MOUSE_BUTTON_DOWN:
-        case SDL_EVENT_MOUSE_BUTTON_UP: {
-            CefBrowserHost::MouseButtonType button_type = MBT_LEFT;
-            if (event.button.button == SDL_BUTTON_RIGHT) {
-                button_type = MBT_RIGHT;
-            } else if (event.button.button == SDL_BUTTON_MIDDLE) {
-                button_type = MBT_MIDDLE;
-            }
+            case SDL_EVENT_MOUSE_BUTTON_DOWN:
+            case SDL_EVENT_MOUSE_BUTTON_UP: {
+                CefBrowserHost::MouseButtonType button_type = MBT_LEFT;
+                if (event.button.button == SDL_BUTTON_RIGHT) {
+                    button_type = MBT_RIGHT;
+                } else if (event.button.button == SDL_BUTTON_MIDDLE) {
+                    button_type = MBT_MIDDLE;
+                }
 
-            bool mouse_up = (event.type == SDL_EVENT_MOUSE_BUTTON_UP);
-            int click_count = event.button.clicks;
-            
-            browser->GetHost()->SendMouseClickEvent(mouse_event, button_type, mouse_up, click_count);
-            break;
+                bool mouse_up = (event.type == SDL_EVENT_MOUSE_BUTTON_UP);
+                int click_count = event.button.clicks;
+                
+                Logger::LogMessage("SendMouseEvent: Sending click event at (" + 
+                                  std::to_string(mouse_event.x) + ", " + std::to_string(mouse_event.y) + 
+                                  ") button=" + std::to_string(button_type) + " up=" + std::to_string(mouse_up));
+                
+                host->SendMouseClickEvent(mouse_event, button_type, mouse_up, click_count);
+                break;
+            }
         }
+    } catch (const std::exception& ex) {
+        Logger::LogMessage("SendMouseEvent: Exception caught - " + std::string(ex.what()));
+    } catch (...) {
+        Logger::LogMessage("SendMouseEvent: Unknown exception caught");
     }
 }
 
@@ -550,6 +600,30 @@ void SDL3Window::Render() {
         SDL_RenderTexture(renderer_, texture_, nullptr, &destRect);
     }
     
+    // Render editor texture if enabled and available
+    if (editor_enabled_ && editor_texture_ && !editor_texture_locked_) {
+        SDL_FRect editorDestRect = {
+            (float)editor_rect_.x,
+            (float)editor_rect_.y,
+            (float)editor_rect_.width,
+            (float)editor_rect_.height
+        };
+        
+        Logger::LogMessage("Render: Rendering editor texture at (" + 
+                          std::to_string(editor_rect_.x) + "," + std::to_string(editor_rect_.y) + 
+                          ") size " + std::to_string(editor_rect_.width) + "x" + std::to_string(editor_rect_.height));
+        
+        if (SDL_RenderTexture(renderer_, editor_texture_, nullptr, &editorDestRect) != 0) {
+            Logger::LogMessage("Render: Failed to render editor texture: " + std::string(SDL_GetError()));
+        } else {
+            Logger::LogMessage("Render: Successfully rendered editor texture");
+        }
+    } else if (editor_enabled_ && editor_texture_locked_) {
+        Logger::LogMessage("Render: Editor texture is locked, skipping render");
+    } else if (editor_enabled_) {
+        Logger::LogMessage("Render: Editor enabled but texture is null");
+    }
+    
     // Present the rendered frame
     SDL_RenderPresent(renderer_);
 }
@@ -560,10 +634,29 @@ OSRRenderHandler::OSRRenderHandler(SDL3Window* window) : window_(window) {
 
 void OSRRenderHandler::GetViewRect(CefRefPtr<CefBrowser> browser, CefRect& rect) {
     if (window_) {
+        // Check if this is the editor browser by URL
+        std::string url = browser->GetMainFrame()->GetURL().ToString();
+        if (url.find("miko://monaco/") == 0) {
+            // This is the editor browser - use editor rect dimensions
+            CefRect editor_rect = window_->GetEditorRect();
+            if (editor_rect.width > 0 && editor_rect.height > 0) {
+                rect.x = 0;
+                rect.y = 0;
+                rect.width = editor_rect.width;
+                rect.height = editor_rect.height;
+                Logger::LogMessage("GetViewRect: Editor browser using editor rect " + 
+                                 std::to_string(rect.width) + "x" + std::to_string(rect.height));
+                return;
+            } else {
+                Logger::LogMessage("GetViewRect: Editor rect has invalid dimensions, using default");
+            }
+        }
+        
+        // For main browser or if editor rect is invalid, use full window size
         rect.x = 0;
         rect.y = 0;
-        rect.width = 1200; // Default width
-        rect.height = 800; // Default height
+        rect.width = DEFAULT_WINDOW_WIDTH; // Default width
+        rect.height = DEFAULT_WINDOW_HEIGHT; // Default height
         
         // Get actual window size and apply DPI scaling
         if (window_->GetSDLWindow()) {
@@ -575,18 +668,18 @@ void OSRRenderHandler::GetViewRect(CefRefPtr<CefBrowser> browser, CefRect& rect)
             rect.width = static_cast<int>(w / dpi_scale);
             rect.height = static_cast<int>(h / dpi_scale);
             
-            Logger::LogMessage("GetViewRect: Physical size " + std::to_string(w) + "x" + std::to_string(h) + 
+            Logger::LogMessage("GetViewRect: Main browser - Physical size " + std::to_string(w) + "x" + std::to_string(h) + 
                              ", DPI scale " + std::to_string(dpi_scale) + 
                              ", Logical size " + std::to_string(rect.width) + "x" + std::to_string(rect.height));
         } else {
             Logger::LogMessage("GetViewRect: Using default size " + std::to_string(rect.width) + "x" + std::to_string(rect.height));
         }
     } else {
-        Logger::LogMessage("GetViewRect: Window is null, using default 1200x800");
+        Logger::LogMessage("GetViewRect: Window is null, using default " + std::to_string(DEFAULT_WINDOW_WIDTH) + "x" + std::to_string(DEFAULT_WINDOW_HEIGHT));
         rect.x = 0;
         rect.y = 0;
-        rect.width = 1200;
-        rect.height = 800;
+        rect.width = DEFAULT_WINDOW_WIDTH;
+        rect.height = DEFAULT_WINDOW_HEIGHT;
     }
 }
 
@@ -603,8 +696,17 @@ void OSRRenderHandler::OnPaint(CefRefPtr<CefBrowser> browser,
     
     Logger::LogMessage("OnPaint: Received paint event " + std::to_string(width) + "x" + std::to_string(height) + ", dirty rects=" + std::to_string(dirtyRects.size()));
 
-    // UpdateTexture now handles create/recreate + copy
-    window_->UpdateTexture(buffer, width, height);
+    // Check if this is the editor browser by URL
+    std::string url = browser->GetMainFrame()->GetURL().ToString();
+    if (url.find("miko://monaco/") == 0) {
+        // This is the editor browser - route to editor texture
+        Logger::LogMessage("OnPaint: Routing editor browser content to UpdateEditorTexture");
+        window_->UpdateEditorTexture(buffer, width, height);
+    } else {
+        // This is the main browser - route to main texture
+        Logger::LogMessage("OnPaint: Routing main browser content to UpdateTexture");
+        window_->UpdateTexture(buffer, width, height);
+    }
 }
 
 bool SimpleClient::OnCursorChange(CefRefPtr<CefBrowser> browser,
@@ -733,6 +835,272 @@ bool SimpleClient::OnQuery(CefRefPtr<CefBrowser> browser,
     
     std::string request_str = request.ToString();
     
+    // Handle JSON-based menu overlay requests
+    if (request_str.find("{") == 0) {
+        try {
+            // Parse JSON request
+            size_t type_pos = request_str.find("\"type\":");
+            if (type_pos != std::string::npos) {
+                size_t type_start = request_str.find("\"", type_pos + 7) + 1;
+                size_t type_end = request_str.find("\"", type_start);
+                std::string type = request_str.substr(type_start, type_end - type_start);
+                
+                if (type == "open_menu_overlay") {
+                    Logger::LogMessage("DEBUG: Starting open_menu_overlay handler");
+                    Logger::LogMessage("DEBUG: Request string: " + request_str);
+                    
+                    try {
+                        Logger::LogMessage("DEBUG: Extracting JSON fields");
+                        // Extract section, x, y from JSON
+                        size_t section_pos = request_str.find("\"section\":");
+                        size_t x_pos = request_str.find("\"x\":");
+                        size_t y_pos = request_str.find("\"y\":");
+                        
+                        Logger::LogMessage("DEBUG: Found positions - section: " + std::to_string(section_pos) + 
+                                         ", x: " + std::to_string(x_pos) + ", y: " + std::to_string(y_pos));
+                        
+                        if (section_pos != std::string::npos && x_pos != std::string::npos && y_pos != std::string::npos) {
+                            Logger::LogMessage("DEBUG: Extracting section");
+                            // Extract section
+                            size_t section_start = request_str.find("\"", section_pos + 10) + 1;
+                            size_t section_end = request_str.find("\"", section_start);
+                            std::string section = request_str.substr(section_start, section_end - section_start);
+                            Logger::LogMessage("DEBUG: Extracted section: " + section);
+                            
+                            Logger::LogMessage("DEBUG: Extracting x coordinate");
+                            // Extract x coordinate (handle numeric values without quotes)
+                            size_t x_colon = request_str.find(":", x_pos);
+                            size_t x_start = x_colon + 1;
+                            // Skip any whitespace
+                            while (x_start < request_str.length() && (request_str[x_start] == ' ' || request_str[x_start] == '\t')) {
+                                x_start++;
+                            }
+                            size_t x_end = request_str.find(",", x_start);
+                            if (x_end == std::string::npos) x_end = request_str.find("}", x_start);
+                            std::string x_str = request_str.substr(x_start, x_end - x_start);
+                            // Trim whitespace
+                            x_str.erase(0, x_str.find_first_not_of(" \t"));
+                            x_str.erase(x_str.find_last_not_of(" \t") + 1);
+                            Logger::LogMessage("DEBUG: x_str before conversion: '" + x_str + "'");
+                            int x = static_cast<int>(std::stod(x_str));
+                            Logger::LogMessage("DEBUG: Extracted x: " + std::to_string(x));
+                            
+                            Logger::LogMessage("DEBUG: Extracting y coordinate");
+                            // Extract y coordinate (handle numeric values without quotes)
+                            size_t y_colon = request_str.find(":", y_pos);
+                            size_t y_start = y_colon + 1;
+                            // Skip any whitespace
+                            while (y_start < request_str.length() && (request_str[y_start] == ' ' || request_str[y_start] == '\t')) {
+                                y_start++;
+                            }
+                            size_t y_end = request_str.find("}", y_start);
+                            if (y_end == std::string::npos) y_end = request_str.find(",", y_start);
+                            std::string y_str = request_str.substr(y_start, y_end - y_start);
+                            // Trim whitespace
+                            y_str.erase(0, y_str.find_first_not_of(" \t"));
+                            y_str.erase(y_str.find_last_not_of(" \t") + 1);
+                            Logger::LogMessage("DEBUG: y_str before conversion: '" + y_str + "'");
+                            int y = static_cast<int>(std::stod(y_str));
+                            Logger::LogMessage("DEBUG: Extracted y: " + std::to_string(y));
+                            
+                            Logger::LogMessage("Processing menu overlay request for section: " + section + " at (" + std::to_string(x) + ", " + std::to_string(y) + ")");
+                            
+                            Logger::LogMessage("DEBUG: About to call OpenMenuOverlay or CloseMenuOverlay");
+                            // Handle menu overlay opening
+                            if (section == "close") {
+                                Logger::LogMessage("DEBUG: Calling CloseMenuOverlay");
+                                CloseMenuOverlay();
+                            } else {
+                                Logger::LogMessage("DEBUG: Calling OpenMenuOverlay");
+                                OpenMenuOverlay(section, x, y);
+                            }
+                            Logger::LogMessage("DEBUG: Successfully completed menu overlay operation");
+                        } else {
+                            Logger::LogMessage("DEBUG: Missing required JSON fields");
+                        }
+                        
+                        callback->Success("success");
+                        return true;
+                    } catch (const std::exception& ex) {
+                        Logger::LogMessage("Exception in open_menu_overlay handler: " + std::string(ex.what()));
+                        callback->Failure(500, "Internal error in menu overlay");
+                        return true;
+                    } catch (...) {
+                        Logger::LogMessage("Unknown exception in open_menu_overlay handler (possibly 0xe06d7363)");
+                        callback->Failure(500, "Unknown error in menu overlay");
+                        return true;
+                    }
+                }
+                else if (type == "menu_item_click") {
+                    try {
+                        // Extract section and action from JSON
+                        size_t section_pos = request_str.find("\"section\":");
+                        size_t action_pos = request_str.find("\"action\":");
+                        
+                        if (section_pos != std::string::npos && action_pos != std::string::npos) {
+                            // Extract section
+                            size_t section_start = request_str.find("\"", section_pos + 10) + 1;
+                            size_t section_end = request_str.find("\"", section_start);
+                            std::string section = request_str.substr(section_start, section_end - section_start);
+                            
+                            // Extract action
+                            size_t action_start = request_str.find("\"", action_pos + 9) + 1;
+                            size_t action_end = request_str.find("\"", action_start);
+                            std::string action = request_str.substr(action_start, action_end - action_start);
+                            
+                            // Log menu item click for debugging
+                            Logger::LogMessage("Menu item clicked - Section: " + section + ", Action: " + action);
+                            
+                            // Close menu overlay after click
+                            CloseMenuOverlay();
+                            
+                            callback->Success("success");
+                            return true;
+                        } else {
+                            Logger::LogMessage("Invalid menu item click parameters");
+                            callback->Failure(400, "Invalid parameters");
+                            return true;
+                        }
+                    } catch (const std::exception& ex) {
+                        Logger::LogMessage("Exception in menu_item_click handler: " + std::string(ex.what()));
+                        callback->Failure(500, "Internal error in menu item click");
+                        return true;
+                    } catch (...) {
+                        Logger::LogMessage("Unknown exception in menu_item_click handler (possibly 0xe06d7363)");
+                        callback->Failure(500, "Unknown error in menu item click");
+                        return true;
+                    }
+                }
+                else if (type == "open_editor") {
+                    try {
+                        // Extract position and dimensions from JSON
+                        size_t x_pos = request_str.find("\"x\":");
+                        size_t y_pos = request_str.find("\"y\":");
+                        size_t width_pos = request_str.find("\"width\":");
+                        size_t height_pos = request_str.find("\"height\":");
+                        
+                        if (x_pos != std::string::npos && y_pos != std::string::npos && 
+                            width_pos != std::string::npos && height_pos != std::string::npos) {
+                            
+                            // Extract x coordinate
+                            size_t x_start = request_str.find(":", x_pos) + 1;
+                            size_t x_end = request_str.find_first_of(",}", x_start);
+                            int x = std::stoi(request_str.substr(x_start, x_end - x_start));
+                            
+                            // Extract y coordinate
+                            size_t y_start = request_str.find(":", y_pos) + 1;
+                            size_t y_end = request_str.find_first_of(",}", y_start);
+                            int y = std::stoi(request_str.substr(y_start, y_end - y_start));
+                            
+                            // Extract width
+                            size_t width_start = request_str.find(":", width_pos) + 1;
+                            size_t width_end = request_str.find_first_of(",}", width_start);
+                            int width = std::stoi(request_str.substr(width_start, width_end - width_start));
+                            
+                            // Extract height
+                            size_t height_start = request_str.find(":", height_pos) + 1;
+                            size_t height_end = request_str.find_first_of(",}", height_start);
+                            int height = std::stoi(request_str.substr(height_start, height_end - height_start));
+                            
+                            Logger::LogMessage("Opening editor at position: " + std::to_string(x) + "," + std::to_string(y) + 
+                                             " with size: " + std::to_string(width) + "x" + std::to_string(height));
+                            
+                            // Open editor using the same technique as menu overlay
+                            OpenEditor(x, y, width, height);
+                            
+                            callback->Success("success");
+                            return true;
+                        } else {
+                            Logger::LogMessage("DEBUG: Missing required JSON fields for editor");
+                            callback->Failure(400, "Missing required parameters");
+                            return true;
+                        }
+                    } catch (const std::exception& ex) {
+                        Logger::LogMessage("Exception in open_editor handler: " + std::string(ex.what()));
+                        callback->Failure(500, "Internal error in editor");
+                        return true;
+                    } catch (...) {
+                        Logger::LogMessage("Unknown exception in open_editor handler (possibly 0xe06d7363)");
+                        callback->Failure(500, "Unknown error in editor");
+                        return true;
+                    }
+                }
+                else if (type == "close_editor") {
+                    try {
+                        Logger::LogMessage("Closing editor");
+                        CloseEditor();
+                        callback->Success("success");
+                        return true;
+                    } catch (const std::exception& ex) {
+                        Logger::LogMessage("Exception in close_editor handler: " + std::string(ex.what()));
+                        callback->Failure(500, "Internal error closing editor");
+                        return true;
+                    } catch (...) {
+                        Logger::LogMessage("Unknown exception in close_editor handler (possibly 0xe06d7363)");
+                        callback->Failure(500, "Unknown error closing editor");
+                        return true;
+                    }
+                }
+                else if (type == "editor_position_update") {
+                    try {
+                        // Extract new position and dimensions from JSON
+                        size_t x_pos = request_str.find("\"x\":");
+                        size_t y_pos = request_str.find("\"y\":");
+                        size_t width_pos = request_str.find("\"width\":");
+                        size_t height_pos = request_str.find("\"height\":");
+                        
+                        if (x_pos != std::string::npos && y_pos != std::string::npos && 
+                            width_pos != std::string::npos && height_pos != std::string::npos) {
+                            
+                            // Extract coordinates and dimensions
+                            size_t x_start = request_str.find(":", x_pos) + 1;
+                            size_t x_end = request_str.find_first_of(",}", x_start);
+                            int x = std::stoi(request_str.substr(x_start, x_end - x_start));
+                            
+                            size_t y_start = request_str.find(":", y_pos) + 1;
+                            size_t y_end = request_str.find_first_of(",}", y_start);
+                            int y = std::stoi(request_str.substr(y_start, y_end - y_start));
+                            
+                            size_t width_start = request_str.find(":", width_pos) + 1;
+                            size_t width_end = request_str.find_first_of(",}", width_start);
+                            int width = std::stoi(request_str.substr(width_start, width_end - width_start));
+                            
+                            size_t height_start = request_str.find(":", height_pos) + 1;
+                            size_t height_end = request_str.find_first_of(",}", height_start);
+                            int height = std::stoi(request_str.substr(height_start, height_end - height_start));
+                            
+                            Logger::LogMessage("Updating editor position to: " + std::to_string(x) + "," + std::to_string(y) + 
+                                             " with size: " + std::to_string(width) + "x" + std::to_string(height));
+                            
+                            // Update editor position using window method
+                            if (window_) {
+                                window_->SetEditorPosition(x, y, width, height);
+                            }
+                            
+                            callback->Success("success");
+                            return true;
+                        } else {
+                            Logger::LogMessage("DEBUG: Missing required JSON fields for editor position update");
+                            callback->Failure(400, "Missing required parameters");
+                            return true;
+                        }
+                    } catch (const std::exception& ex) {
+                        Logger::LogMessage("Exception in editor_position_update handler: " + std::string(ex.what()));
+                        callback->Failure(500, "Internal error updating editor position");
+                        return true;
+                    } catch (...) {
+                        Logger::LogMessage("Unknown exception in editor_position_update handler (possibly 0xe06d7363)");
+                        callback->Failure(500, "Unknown error updating editor position");
+                        return true;
+                    }
+                }
+            }
+        } catch (const std::exception&) {
+            callback->Failure(-1, "Failed to parse menu overlay request");
+            return true;
+        }
+    }
+    
     // Handle IPC calls
     if (request_str.find("ipc_call:") == 0) {
         // Parse IPC call format: "ipc_call:method:message"
@@ -1017,6 +1385,41 @@ void SimpleClient::OnAfterCreated(CefRefPtr<CefBrowser> browser) {
     if (browser_list_.size() == 1) {
         // First CEF browser created
         Logger::LogMessage("First CEF browser created");
+    } else {
+        // Check if this is a menu overlay browser and apply transparency
+        std::string url = browser->GetMainFrame()->GetURL().ToString();
+        Logger::LogMessage("OnAfterCreated: Checking URL: " + url);
+        if (url.find("miko://menuoverlay/") == 0) {
+            // Get the native window handle for the overlay
+            HWND overlay_hwnd = browser->GetHost()->GetWindowHandle();
+            if (overlay_hwnd) {
+                // Apply transparency settings to the overlay window
+                SetLayeredWindowAttributes(overlay_hwnd, RGB(0, 0, 0), 240, LWA_COLORKEY | LWA_ALPHA);
+                Logger::LogMessage("Applied transparency to menu overlay window");
+                
+                // Ensure the window stays on top
+                SetWindowPos(overlay_hwnd, HWND_TOPMOST, 0, 0, 0, 0, 
+                           SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
+                Logger::LogMessage("Set menu overlay window to stay on top");
+            } else {
+                Logger::LogMessage("Failed to get overlay window handle for transparency");
+            }
+        } else if (url.find("miko://monaco/") == 0) {
+            // This is the editor browser - store reference for OSR
+            Logger::LogMessage("OnAfterCreated: Found monaco URL, setting editor browser");
+            if (window_) {
+                window_->SetEditorBrowser(browser);
+                Logger::LogMessage("Editor browser created and stored for OSR rendering");
+                
+                // Force initial resize/paint to ensure texture is created
+                browser->GetHost()->WasResized();
+                Logger::LogMessage("Called WasResized() to trigger initial paint for editor browser");
+            } else {
+                Logger::LogMessage("OnAfterCreated: window_ is null, cannot set editor browser");
+            }
+        } else {
+            Logger::LogMessage("OnAfterCreated: URL does not match any expected patterns");
+        }
     }
 }
 
@@ -1071,9 +1474,33 @@ void SimpleClient::OnLoadStart(CefRefPtr<CefBrowser> browser,
                               TransitionType transition_type) {
     CEF_REQUIRE_UI_THREAD();
     
+    // Add null checks to prevent crashes
+    if (!browser || !frame) {
+        Logger::LogMessage("OnLoadStart: browser or frame is null, skipping");
+        return;
+    }
+    
     if (frame->IsMain()) {
         // Main frame started loading
         Logger::LogMessage("Main frame started loading");
+        
+        // Check if this is the editor browser and set reference
+        CefString cef_url = frame->GetURL();
+        if (!cef_url.empty()) {
+            std::string url = cef_url.ToString();
+            Logger::LogMessage("OnLoadStart: Checking URL: " + url);
+            if (url.find("miko://monaco/") == 0) {
+                Logger::LogMessage("OnLoadStart: Found monaco URL, setting editor browser");
+                if (window_) {
+                    window_->SetEditorBrowser(browser);
+                    Logger::LogMessage("Editor browser reference set in OnLoadStart");
+                } else {
+                    Logger::LogMessage("OnLoadStart: window_ is null, cannot set editor browser");
+                }
+            }
+        } else {
+            Logger::LogMessage("OnLoadStart: URL is empty, skipping");
+        }
     }
 }
 
@@ -1141,7 +1568,7 @@ bool SimpleClient::OnPreKeyEvent(CefRefPtr<CefBrowser> browser,
             windowInfo.SetAsPopup(nullptr, "DevTools");
             windowInfo.bounds.x = 100;
             windowInfo.bounds.y = 100;
-            windowInfo.bounds.width = 800;
+            windowInfo.bounds.width = MIN_WINDOW_WIDTH;
             windowInfo.bounds.height = 600;
             
             browser->GetHost()->ShowDevTools(windowInfo, this, settings, CefPoint());
@@ -1235,3 +1662,434 @@ void SimpleClient::SendMouseWheelEvent(int x, int y, int delta_x, int delta_y) {
     }
 }
 
+// Editor sublayer management methods
+void SDL3Window::EnableEditor(bool enable) {
+    editor_enabled_ = enable;
+    
+    // Reset texture locking state when disabling editor
+    if (!enable) {
+        editor_texture_locked_ = false;
+        Logger::LogMessage("Editor sublayer disabled - texture lock state reset");
+    }
+    
+    Logger::LogMessage("Editor sublayer " + std::string(enable ? "enabled" : "disabled"));
+}
+
+void SDL3Window::SetEditorPosition(int x, int y, int width, int height) {
+    editor_rect_.x = x;
+    editor_rect_.y = y;
+    editor_rect_.width = width;
+    editor_rect_.height = height;
+    Logger::LogMessage("Editor position set to (" + std::to_string(x) + ", " + std::to_string(y) + 
+                      ") with size " + std::to_string(width) + "x" + std::to_string(height));
+}
+
+void SDL3Window::SetEditorBrowser(CefRefPtr<CefBrowser> browser) {
+    editor_browser_ = browser;
+    Logger::LogMessage("Editor browser reference set");
+}
+
+void SDL3Window::UpdateEditorTexture(const void* buffer, int width, int height) {
+    Logger::LogMessage("UpdateEditorTexture called: " + std::to_string(width) + "x" + std::to_string(height) + 
+                      ", editor_enabled_=" + (editor_enabled_ ? "true" : "false") + 
+                      ", editor_browser_=" + (editor_browser_ ? "valid" : "null"));
+    
+    // Use mutex to prevent concurrent texture operations
+    std::lock_guard<std::mutex> lock(editor_texture_mutex_);
+    
+    // Check if texture is already locked (should not happen with mutex protection)
+    if (editor_texture_locked_) {
+        Logger::LogMessage("UpdateEditorTexture: Texture is already locked, this should not happen with mutex protection");
+        return;
+    }
+    
+    // Add null buffer check first
+    if (!buffer) {
+        Logger::LogMessage("UpdateEditorTexture: Buffer is null!");
+        return;
+    }
+    
+    // Add dimension validation
+    if (width <= 0 || height <= 0) {
+        Logger::LogMessage("UpdateEditorTexture: Invalid dimensions - width: " + std::to_string(width) + ", height: " + std::to_string(height));
+        return;
+    }
+    
+    if (!editor_enabled_ || !editor_browser_) {
+        Logger::LogMessage("UpdateEditorTexture: Early return - editor not enabled or browser null");
+        return;
+    }
+    
+    if (!renderer_) {
+        Logger::LogMessage("UpdateEditorTexture: Renderer is null!");
+        return;
+    }
+    
+    // Store current texture dimensions for comparison
+    static int current_texture_width = 0;
+    static int current_texture_height = 0;
+    
+    // Create or recreate editor texture if dimensions changed
+    if (!editor_texture_ || 
+        current_texture_width != width || 
+        current_texture_height != height) {
+        
+        Logger::LogMessage("UpdateEditorTexture: Creating new texture (old: " + 
+                          std::to_string(current_texture_width) + "x" + std::to_string(current_texture_height) + 
+                          ", new: " + std::to_string(width) + "x" + std::to_string(height) + ")");
+        
+        if (editor_texture_) {
+            SDL_DestroyTexture(editor_texture_);
+            Logger::LogMessage("UpdateEditorTexture: Destroyed old texture");
+        }
+        
+        editor_texture_ = SDL_CreateTexture(renderer_, 
+                                          SDL_PIXELFORMAT_BGRA32, 
+                                          SDL_TEXTUREACCESS_STREAMING, 
+                                          width, height);
+        
+        if (!editor_texture_) {
+            Logger::LogMessage("UpdateEditorTexture: Failed to create editor texture: " + std::string(SDL_GetError()));
+            return;
+        }
+        
+        // Enable alpha blending for the editor texture
+        if (SDL_SetTextureBlendMode(editor_texture_, SDL_BLENDMODE_BLEND) != 0) {
+            Logger::LogMessage("UpdateEditorTexture: Failed to set blend mode: " + std::string(SDL_GetError()));
+        }
+        
+        // Update stored dimensions
+        current_texture_width = width;
+        current_texture_height = height;
+        
+        Logger::LogMessage("UpdateEditorTexture: Successfully created editor texture: " + std::to_string(width) + "x" + std::to_string(height));
+    }
+    
+    // Update texture with CEF buffer data
+    void* pixels;
+    int pitch;
+    
+    // Set lock state before attempting to lock
+    editor_texture_locked_ = true;
+    
+    if (SDL_LockTexture(editor_texture_, nullptr, &pixels, &pitch) == 0) {
+        Logger::LogMessage("UpdateEditorTexture: Successfully locked texture - pitch=" + std::to_string(pitch) + 
+                          ", bytes_per_row=" + std::to_string(width * 4));
+        
+        // Validate the lock was successful and we have valid data
+        if (!pixels) {
+            Logger::LogMessage("UpdateEditorTexture: Locked texture but pixels pointer is null");
+            SDL_UnlockTexture(editor_texture_);
+            editor_texture_locked_ = false;
+            return;
+        }
+        
+        if (pitch <= 0) {
+            Logger::LogMessage("UpdateEditorTexture: Invalid pitch: " + std::to_string(pitch));
+            SDL_UnlockTexture(editor_texture_);
+            editor_texture_locked_ = false;
+            return;
+        }
+        
+        // Safe row-by-row copying that respects texture pitch
+        const uint8_t* src = static_cast<const uint8_t*>(buffer);
+        uint8_t* dst = static_cast<uint8_t*>(pixels);
+        const int bytes_per_row = width * 4; // 4 bytes per pixel (BGRA)
+        
+        // Validate pitch is reasonable
+        if (pitch < bytes_per_row) {
+            Logger::LogMessage("UpdateEditorTexture: Invalid pitch " + std::to_string(pitch) + " < " + std::to_string(bytes_per_row));
+            SDL_UnlockTexture(editor_texture_);
+            editor_texture_locked_ = false;
+            return;
+        }
+        
+        for (int y = 0; y < height; ++y) {
+            memcpy(dst + y * pitch, src + y * bytes_per_row, bytes_per_row);
+        }
+        
+        SDL_UnlockTexture(editor_texture_);
+        editor_texture_locked_ = false; // Mark as unlocked after successful unlock
+        Logger::LogMessage("UpdateEditorTexture: Successfully updated texture data");
+    } else {
+        editor_texture_locked_ = false; // Reset lock state on failure
+        Logger::LogMessage("UpdateEditorTexture: Failed to lock editor texture: " + std::string(SDL_GetError()));
+    }
+}
+
+// Menu overlay management methods
+void SimpleClient::OpenEditor(int x, int y, int width, int height) {
+    CEF_REQUIRE_UI_THREAD();
+    
+    try {
+        Logger::LogMessage("OpenEditor called - x: " + std::to_string(x) + ", y: " + std::to_string(y) + 
+                          ", width: " + std::to_string(width) + ", height: " + std::to_string(height));
+        
+        if (window_) {
+            Logger::LogMessage("Creating OSR editor browser");
+            
+            // Enable editor in the window
+            window_->EnableEditor(true);
+            window_->SetEditorPosition(x, y, width, height);
+            
+            // Create OSR browser for the editor
+            CefWindowInfo window_info;
+            window_info.SetAsWindowless(nullptr); // Use OSR mode
+            
+            Logger::LogMessage("Editor OSR bounds - x: " + std::to_string(x) + 
+                             ", y: " + std::to_string(y) + ", w: " + std::to_string(width) + 
+                             ", h: " + std::to_string(height));
+            
+            CefBrowserSettings browser_settings;
+            browser_settings.javascript_close_windows = STATE_ENABLED;
+            browser_settings.background_color = 0x00FFFFFF; // White background for editor
+            
+            // Create editor URL using monaco resource
+            std::string editor_url = "miko://monaco/index.html";
+            Logger::LogMessage("Editor URL: " + editor_url);
+            
+            // Create OSR render handler for the editor
+            CefRefPtr<OSRRenderHandler> render_handler = new OSRRenderHandler(window_);
+            
+            bool browser_created = CefBrowserHost::CreateBrowser(window_info, this, editor_url, browser_settings, nullptr, nullptr);
+            Logger::LogMessage("CreateBrowser result: " + std::string(browser_created ? "true" : "false"));
+            
+            Logger::LogMessage("Monaco editor opened with OSR at position (" + std::to_string(x) + ", " + std::to_string(y) + ") " +
+                             "with size (" + std::to_string(width) + "x" + std::to_string(height) + 
+                             ") and URL: " + editor_url);
+        } else {
+            Logger::LogMessage("Failed to open editor: window is null");
+        }
+    } catch (const std::exception& ex) {
+        Logger::LogMessage("Exception in OpenEditor: " + std::string(ex.what()));
+    } catch (...) {
+        Logger::LogMessage("Unknown exception in OpenEditor");
+    }
+}
+
+void SimpleClient::CloseEditor() {
+    CEF_REQUIRE_UI_THREAD();
+    
+    try {
+        // Find and close any editor browsers
+        for (auto it = browser_list_.begin(); it != browser_list_.end(); ++it) {
+            CefRefPtr<CefBrowser> browser = *it;
+            if (browser && browser->GetHost()) {
+                std::string url = browser->GetMainFrame()->GetURL().ToString();
+                // Check for miko:// protocol URLs with monaco
+                if (url.find("miko://monaco/") == 0) {
+                    browser->GetHost()->CloseBrowser(true);
+                    if (window_) {
+                        window_->EnableEditor(false);
+                    }
+                    Logger::LogMessage("Monaco editor closed");
+                    break;
+                }
+            }
+        }
+    } catch (const std::exception& ex) {
+        Logger::LogMessage("Exception in CloseEditor: " + std::string(ex.what()));
+    } catch (...) {
+        Logger::LogMessage("Unknown exception in CloseEditor");
+    }
+}
+
+void SimpleClient::OpenMenuOverlay(const std::string& section, int x, int y) {
+    CEF_REQUIRE_UI_THREAD();
+    
+    try {
+        Logger::LogMessage("OpenMenuOverlay called - section: " + section + ", x: " + std::to_string(x) + ", y: " + std::to_string(y));
+        
+        if (!browser_list_.empty()) {
+            CefRefPtr<CefBrowser> browser = browser_list_.front();
+            if (browser && browser->GetHost()) {
+                Logger::LogMessage("Browser available, creating overlay window");
+                
+                // Get screen dimensions for positioning calculations
+                int screenWidth = GetSystemMetrics(SM_CXSCREEN);
+                int screenHeight = GetSystemMetrics(SM_CYSCREEN);
+                
+                // Get current cursor position for smart positioning
+                POINT cursor_pos;
+                GetCursorPos(&cursor_pos);
+                
+                // Auto-size based on content type and screen size
+                int overlayWidth, overlayHeight;
+                if (section == "file" || section == "edit" || section == "view") {
+                    // Larger size for main menu sections
+                    overlayWidth = std::min(400, screenWidth / 3);
+                    overlayHeight = std::min(500, screenHeight / 2);
+                } else if (section == "tools" || section == "help") {
+                    // Medium size for secondary sections
+                    overlayWidth = std::min(350, screenWidth / 4);
+                    overlayHeight = std::min(400, screenHeight / 3);
+                } else {
+                    // Default compact size for other sections
+                    overlayWidth = std::min(300, screenWidth / 5);
+                    overlayHeight = std::min(350, screenHeight / 4);
+                }
+                
+                // Smart positioning relative to cursor with fallback to provided coordinates
+                int overlayX, overlayY;
+                if (x == 0 && y == 0) {
+                    // Use cursor position if no specific coordinates provided
+                    overlayX = cursor_pos.x + 10; // Offset slightly from cursor
+                    overlayY = cursor_pos.y + 10;
+                } else {
+                    // Use provided coordinates
+                    overlayX = x;
+                    overlayY = y;
+                }
+                
+                // Adjust X position if overlay would go off-screen
+                if (overlayX + overlayWidth > screenWidth) {
+                    if (x == 0 && y == 0) {
+                        overlayX = cursor_pos.x - overlayWidth - 10; // Position to the left of cursor
+                    } else {
+                        overlayX = screenWidth - overlayWidth - 10; // 10px margin
+                    }
+                }
+                if (overlayX < 0) {
+                    overlayX = 10; // 10px margin from left
+                }
+                
+                // Adjust Y position if overlay would go off-screen
+                if (overlayY + overlayHeight > screenHeight) {
+                    if (x == 0 && y == 0) {
+                        overlayY = cursor_pos.y - overlayHeight - 10; // Position above cursor
+                    } else {
+                        overlayY = screenHeight - overlayHeight - 10; // 10px margin
+                    }
+                }
+                if (overlayY < 0) {
+                    overlayY = 10; // 10px margin from top
+                }
+                
+                // Create a new browser window for the menu overlay
+                CefWindowInfo window_info;
+                window_info.SetAsPopup(window_->GetHWND(), "MenuOverlay");
+                
+                // Set window style for transparency and layered window
+                window_info.ex_style = WS_EX_LAYERED | WS_EX_TOPMOST | WS_EX_TOOLWINDOW;
+                window_info.style = WS_POPUP | WS_VISIBLE;
+                
+                // Position the overlay window with calculated bounds
+                window_info.bounds.x = overlayX;
+                window_info.bounds.y = overlayY;
+                window_info.bounds.width = overlayWidth;
+                window_info.bounds.height = overlayHeight;
+                
+                Logger::LogMessage("Auto-sized window bounds - x: " + std::to_string(overlayX) + 
+                                 ", y: " + std::to_string(overlayY) + 
+                                 ", w: " + std::to_string(overlayWidth) + 
+                                 ", h: " + std::to_string(overlayHeight));
+                
+                CefBrowserSettings browser_settings;
+                browser_settings.javascript_close_windows = STATE_ENABLED;
+                browser_settings.background_color = 0x00000000; // Transparent background
+                
+                // Create Steam-like overlay routing URL
+                std::string overlay_url = BuildOverlayURL(section, overlayX, overlayY, overlayWidth, overlayHeight);
+                Logger::LogMessage("Overlay URL created, length: " + std::to_string(overlay_url.length()));
+                Logger::LogMessage("URL preview (first 200 chars): " + overlay_url.substr(0, 200));
+                
+                bool browser_created = CefBrowserHost::CreateBrowser(window_info, this, overlay_url, browser_settings, nullptr, nullptr);
+                Logger::LogMessage("CreateBrowser result: " + std::string(browser_created ? "true" : "false"));
+                
+                Logger::LogMessage("Menu overlay opened for section: " + section + 
+                                 " at auto-positioned (" + std::to_string(overlayX) + ", " + std::to_string(overlayY) + 
+                                 ") with size (" + std::to_string(overlayWidth) + "x" + std::to_string(overlayHeight) + 
+                                 ") and URL: " + overlay_url);
+            } else {
+                Logger::LogMessage("Failed to open menu overlay: browser or host is null");
+            }
+        } else {
+            Logger::LogMessage("Failed to open menu overlay: no browsers available");
+        }
+    } catch (const std::exception& ex) {
+        Logger::LogMessage("Exception in OpenMenuOverlay: " + std::string(ex.what()));
+    } catch (...) {
+        Logger::LogMessage("Unknown exception in OpenMenuOverlay (possibly 0xe06d7363)");
+    }
+}
+
+void SimpleClient::CloseMenuOverlay() {
+    CEF_REQUIRE_UI_THREAD();
+    
+    try {
+        // Find and close any overlay browsers
+        for (auto it = browser_list_.begin(); it != browser_list_.end(); ++it) {
+            CefRefPtr<CefBrowser> browser = *it;
+            if (browser && browser->GetHost()) {
+                std::string url = browser->GetMainFrame()->GetURL().ToString();
+                // Check for miko:// protocol URLs with menuoverlay
+                if (url.find("miko://menuoverlay/") == 0) {
+                    browser->GetHost()->CloseBrowser(true);
+                    Logger::LogMessage("Menu overlay closed");
+                    break;
+                }
+            }
+        }
+    } catch (const std::exception& ex) {
+        Logger::LogMessage("Exception in CloseMenuOverlay: " + std::string(ex.what()));
+    } catch (...) {
+        Logger::LogMessage("Unknown exception in CloseMenuOverlay (possibly 0xe06d7363)");
+    }
+}
+
+
+
+std::string SimpleClient::GetMenuOverlayHTML(const std::string& section) {
+    Logger::LogMessage("GetMenuOverlayHTML called for section: " + section);
+    
+    // Use embedded HTML resource from resourceutil
+    std::vector<uint8_t> html_data = ResourceUtil::LoadBinaryResource(ResourceUtil::IDR_HTML_MENUOVERLAY);
+    Logger::LogMessage("LoadBinaryResource returned " + std::to_string(html_data.size()) + " bytes");
+    
+    if (!html_data.empty()) {
+        std::string html_content(html_data.begin(), html_data.end());
+        Logger::LogMessage("HTML content converted to string, length: " + std::to_string(html_content.length()));
+        Logger::LogMessage("HTML preview (first 100 chars): " + html_content.substr(0, 100));
+        return html_content;
+    }
+    
+    // Fallback if resource is not available
+    Logger::LogMessage("WARNING: Using fallback HTML - resource not available");
+    return "<html><body>Menu overlay not available</body></html>";
+}
+
+std::string SimpleClient::BuildOverlayURL(const std::string& section, int x, int y, int width, int height) {
+    Logger::LogMessage("BuildOverlayURL called - section: " + section);
+    
+    // Get current process ID and other parameters for URL parameters
+    DWORD pid = GetCurrentProcessId();
+    int browser_id = -1;
+    if (!browser_list_.empty()) {
+        browser_id = browser_list_.front()->GetIdentifier();
+    }
+    
+    // Get screen dimensions
+    int screen_width = GetSystemMetrics(SM_CXSCREEN);
+    int screen_height = GetSystemMetrics(SM_CYSCREEN);
+    int create_flags = 4538634;
+    
+    Logger::LogMessage("Building miko:// URL with parameters - pid: " + std::to_string(pid) + ", browser_id: " + std::to_string(browser_id));
+    
+    // Use miko:// protocol to serve HTML directly from binary resources with parameters
+    std::string overlay_url = "miko://menuoverlay/index.html"
+        "?createflags=" + std::to_string(create_flags) +
+        "&pid=" + std::to_string(pid) +
+        "&browser=" + std::to_string(browser_id) +
+        "&screenavailwidth=" + std::to_string(screen_width) +
+        "&screenavailheight=" + std::to_string(screen_height) +
+        "&section=" + section +
+        "&x=" + std::to_string(x) +
+        "&y=" + std::to_string(y) +
+        "&width=" + std::to_string(width) +
+        "&height=" + std::to_string(height);
+    
+    Logger::LogMessage("Miko URL created: " + overlay_url);
+    
+    return overlay_url;
+}
+
diff --git a/app/client/client.hpp b/app/client/client.hpp
index 0cfec39..93c7d20 100644
--- a/app/client/client.hpp
+++ b/app/client/client.hpp
@@ -25,6 +25,7 @@
 #include <list>
 #include <memory>
 #include <string>
+#include <mutex>
 
 // Forward declarations
 std::string GetDataURI(const std::string& data, const std::string& mime_type);
@@ -75,12 +76,31 @@ public:
     SDL_Renderer* GetRenderer() const { return renderer_; }
     SDL_Texture* GetTexture() const { return texture_; }
     HWND GetHWND() const;
+    int GetWidth() const { return width_; }
+    int GetHeight() const { return height_; }
     
     // CEF OSR integration
     void UpdateTexture(const void* buffer, int width, int height);
     void Resize(int width, int height);
     void SetClient(CefRefPtr<SimpleClient> client) { client_ = client; }
     
+    // Menu overlay management
+    void ShowMenuOverlay(const std::string& section, int x, int y);
+    void HideMenuOverlay();
+    bool IsMenuOverlayVisible() const;
+    
+    // Editor sublayer management
+    void EnableEditor(bool enable);
+    void SetEditorPosition(int x, int y, int width, int height);
+    void SetEditorBrowser(CefRefPtr<CefBrowser> browser);
+    bool IsEditorEnabled() const { return editor_enabled_; }
+    CefRect GetEditorRect() const { return editor_rect_; }
+    CefRefPtr<CefBrowser> GetEditorBrowser() const { return editor_browser_; }
+    void UpdateEditorTexture(const void* buffer, int width, int height);
+    
+    // Thread safety for editor texture updates
+    std::mutex editor_texture_mutex_;
+    
     // DX11 Renderer integration
     bool IsDX11Available() const { return dx11_renderer_ && dx11_renderer_->IsInitialized(); }
     void EnableDX11Rendering(bool enable);
@@ -136,6 +156,19 @@ private:
     // DPI scaling support
     float dpi_scale_;
     
+    // Menu overlay state
+    bool menu_overlay_visible_;
+    std::string current_menu_section_;
+    int menu_overlay_x_;
+    int menu_overlay_y_;
+    
+    // Editor sublayer management
+    bool editor_enabled_;
+    CefRect editor_rect_;
+    CefRefPtr<CefBrowser> editor_browser_;
+    SDL_Texture* editor_texture_;
+    bool editor_texture_locked_;
+    
     void InitializeDwmApi();
     void UpdateWindowStyle();
 };
@@ -312,6 +345,17 @@ public:
     void SendMouseWheelEvent(int x, int y, int delta_x, int delta_y);
     void SendKeyEvent(const CefKeyEvent& event);
     void SendFocusEvent(bool set_focus);
+    
+    // Menu overlay management
+    void OpenMenuOverlay(const std::string& section, int x, int y);
+    void CloseMenuOverlay();
+    
+    // Editor management
+    void OpenEditor(int x, int y, int width, int height);
+    void CloseEditor();
+    
+    std::string GetMenuOverlayHTML(const std::string& section);
+    std::string BuildOverlayURL(const std::string& section, int x, int y, int width, int height);
 
 private:
     typedef std::list<CefRefPtr<CefBrowser>> BrowserList;
diff --git a/app/main.cpp b/app/main.cpp
index 3fcf032..18c7a03 100644
--- a/app/main.cpp
+++ b/app/main.cpp
@@ -18,6 +18,7 @@
 #include "include/cef_frame.h"
 #include "include/wrapper/cef_helpers.h"
 #include "include/wrapper/cef_closure_task.h"
+#include "utils/config.hpp"
 #include "include/base/cef_bind.h"
 
 #include "client/client.hpp"
@@ -55,35 +56,52 @@ std::string GetDownloadPath(const std::string& suggested_name);
 // Simple CEF App implementation for OSR
 
 
-// Handle SDL events and CEF message loop
 void HandleEvents() {
     SDL_Event event;
     
-    while (SDL_PollEvent(&event)) {
-        if (g_sdl_window && g_sdl_window->HandleEvent(event)) {
-            continue;
+    try {
+        while (SDL_PollEvent(&event)) {
+            if (g_sdl_window && g_sdl_window->HandleEvent(event)) {
+                continue;
+            }
+            
+            // Handle application-level events
+            switch (event.type) {
+                case SDL_EVENT_QUIT:
+                    g_is_closing = true;
+                    if (g_client) {
+                        try {
+                            g_client->CloseAllBrowsers(false);
+                        } catch (const std::exception& ex) {
+                            Logger::LogMessage("Exception during browser close: " + std::string(ex.what()));
+                        } catch (...) {
+                            Logger::LogMessage("Unknown exception during browser close");
+                        }
+                    }
+                    break;
+                    
+                default:
+                    break;
+            }
         }
         
-        // Handle application-level events
-        switch (event.type) {
-            case SDL_EVENT_QUIT:
-                g_is_closing = true;
-                if (g_client) {
+        // Check if window should close
+        if (g_sdl_window && g_sdl_window->ShouldClose()) {
+            g_is_closing = true;
+            if (g_client) {
+                try {
                     g_client->CloseAllBrowsers(false);
+                } catch (const std::exception& ex) {
+                    Logger::LogMessage("Exception during window close: " + std::string(ex.what()));
+                } catch (...) {
+                    Logger::LogMessage("Unknown exception during window close");
                 }
-                break;
-                
-            default:
-                break;
-        }
-    }
-    
-    // Check if window should close
-    if (g_sdl_window && g_sdl_window->ShouldClose()) {
-        g_is_closing = true;
-        if (g_client) {
-            g_client->CloseAllBrowsers(false);
+            }
         }
+    } catch (const std::exception& ex) {
+        Logger::LogMessage("Exception in HandleEvents: " + std::string(ex.what()));
+    } catch (...) {
+        Logger::LogMessage("Unknown exception in HandleEvents");
     }
 }
 
@@ -295,6 +313,24 @@ int WINAPI WinMain(HINSTANCE hInstance,
     
     // Set locale
     CefString(&settings.locale).FromASCII("en-US");
+    
+    // Enable remote debugging on port 9222
+    settings.remote_debugging_port = 9222;
+    
+    // Additional settings for remote debugging to work properly
+    CefString(&settings.user_agent).FromASCII("MikoIDE/1.0 Chrome");
+    
+    // Enable debugging features and prevent connection drops
+    // Note: Certificate error handling is managed through CEF command line switches
+    
+    // Ensure debugging works by disabling sandbox (already set above)
+    // and enabling logging for debugging
+    settings.log_severity = LOGSEVERITY_INFO;
+    
+    // Set command line switches for better debugging stability
+    CefString(&settings.javascript_flags).FromASCII("--expose-gc --allow-natives-syntax");
+    
+    Logger::LogMessage("Remote debugging enabled on port 9222 with enhanced stability settings");
 
     // Debug output for paths
     Logger::LogMessage("exeDir=" + exeDir.string());
@@ -333,7 +369,7 @@ int WINAPI WinMain(HINSTANCE hInstance,
 
     // Initialize SDL3 Window
     g_sdl_window = std::make_unique<SDL3Window>();
-    if (!g_sdl_window->Initialize(1200, 800)) {
+    if (!g_sdl_window->Initialize(DEFAULT_WINDOW_WIDTH, DEFAULT_WINDOW_HEIGHT)) {
         Logger::LogMessage("Failed to initialize SDL3 window");
         if (g_splash_screen) {
             g_splash_screen->Hide();
@@ -348,31 +384,71 @@ int WINAPI WinMain(HINSTANCE hInstance,
         g_splash_screen->UpdateStatus(L"Creating application window...");
     }
 
-    // Create CEF client and browser
-    g_client = new SimpleClient(g_sdl_window.get());
-    
-    if (g_splash_screen) {
-        g_splash_screen->UpdateStatus(L"Loading application...");
-    }
+    // Create CEF client and browser with exception handling
+    try {
+        g_client = new SimpleClient(g_sdl_window.get());
+        
+        if (g_splash_screen) {
+            g_splash_screen->UpdateStatus(L"Loading application...");
+        }
 
-    // Configure browser settings
-    CefBrowserSettings browser_settings;
-    browser_settings.windowless_frame_rate = 0; // 60 FPS for smooth rendering
-    
-    // Configure window info for off-screen rendering
-    CefWindowInfo window_info;
-    window_info.SetAsWindowless(g_sdl_window->GetHWND());
-    
-    // Create the browser synchronously to prevent race conditions
-    CefRefPtr<CefBrowser> browser = CefBrowserHost::CreateBrowserSync(window_info, g_client, AppConfig::GetStartupUrl(), browser_settings, nullptr, nullptr);
-    
-    if (!browser) {
-        Logger::LogMessage("Failed to create CEF browser");
+        // Configure browser settings
+        CefBrowserSettings browser_settings;
+        browser_settings.windowless_frame_rate = 0; // 60 FPS for smooth rendering
+        
+        // Enable debugging features for better remote debugging stability
+        browser_settings.javascript = STATE_ENABLED;
+        browser_settings.javascript_close_windows = STATE_ENABLED;
+        browser_settings.javascript_access_clipboard = STATE_ENABLED;
+        browser_settings.javascript_dom_paste = STATE_ENABLED;
+        
+        // Configure window info for off-screen rendering
+        CefWindowInfo window_info;
+        window_info.SetAsWindowless(g_sdl_window->GetHWND());
+
+        // Create the browser synchronously to prevent race conditions
+        CefRefPtr<CefBrowser> browser = CefBrowserHost::CreateBrowserSync(window_info, g_client, AppConfig::GetStartupUrl(), browser_settings, nullptr, nullptr);
+        
+        if (!browser) {
+            Logger::LogMessage("Failed to create CEF browser");
+            CefShutdown();
+            return 1;
+        }
+        
+        Logger::LogMessage("CEF browser created successfully");
+        
+        // Automatically open editor in the black screen area
+        // Y: 124 to end - 24, full width
+        if (g_client && g_sdl_window) {
+            int window_width = g_sdl_window->GetWidth();
+            int window_height = g_sdl_window->GetHeight();
+            
+            int editor_x = 0;                    // Start at left edge (full width)
+            int editor_y = 124;                 // Start at Y: 124
+            int editor_width = window_width;    // Full width
+            int editor_height = window_height - 124 - 24;  // From Y:124 to end-24
+            
+            Logger::LogMessage("Auto-opening editor at position (" + std::to_string(editor_x) + ", " + 
+                             std::to_string(editor_y) + ") with size (" + std::to_string(editor_width) + 
+                             "x" + std::to_string(editor_height) + ")");
+            
+            g_client->OpenEditor(editor_x, editor_y, editor_width, editor_height);
+        }
+    } catch (const std::exception& ex) {
+        Logger::LogMessage("Exception during CEF browser creation: " + std::string(ex.what()));
+        if (g_splash_screen) {
+            g_splash_screen->Hide();
+        }
+        CefShutdown();
+        return 1;
+    } catch (...) {
+        Logger::LogMessage("Unknown exception during CEF browser creation (possibly 0xe06d7363)");
+        if (g_splash_screen) {
+            g_splash_screen->Hide();
+        }
         CefShutdown();
         return 1;
     }
-    
-    Logger::LogMessage("CEF browser created successfully");
 
     // Hide splash screen once the browser is created and ready
     if (g_splash_screen) {
@@ -380,25 +456,41 @@ int WINAPI WinMain(HINSTANCE hInstance,
         g_splash_screen.reset();
     }
 
-    // Main message loop
+    // Main message loop with exception handling
     while (!g_is_closing) {
-        // Handle SDL events
-        HandleEvents();
-        
-        // Render the window
-        if (g_sdl_window) {
-            g_sdl_window->Render();
-        }
-        
-        // Process CEF message loop
-        CefDoMessageLoopWork();
-        
-        // Small delay to prevent 100% CPU usage
-        SDL_Delay(1);
-        
-        // Check if all browsers are closed
-        if (g_client && !g_client->HasBrowsers() && g_is_closing) {
-            break;
+        try {
+            // Handle SDL events
+            HandleEvents();
+            
+            // Render the window
+            if (g_sdl_window) {
+                g_sdl_window->Render();
+            }
+            
+            // Process CEF message loop with exception handling
+            try {
+                CefDoMessageLoopWork();
+            } catch (const std::exception& ex) {
+                Logger::LogMessage("CEF message loop exception: " + std::string(ex.what()));
+                // Continue running to maintain stability
+            } catch (...) {
+                Logger::LogMessage("Unknown CEF message loop exception caught (possibly 0xe06d7363)");
+                // Continue running to maintain stability
+            }
+            
+            // Small delay to prevent 100% CPU usage
+            SDL_Delay(1);
+            
+            // Check if all browsers are closed
+            if (g_client && !g_client->HasBrowsers() && g_is_closing) {
+                break;
+            }
+        } catch (const std::exception& ex) {
+            Logger::LogMessage("Main loop exception: " + std::string(ex.what()));
+            // Continue running unless it's a critical error
+        } catch (...) {
+            Logger::LogMessage("Unknown main loop exception caught - continuing execution");
+            // Continue running to maintain stability
         }
     }
 
diff --git a/app/resources/resources.cpp b/app/resources/resources.cpp
index faf17f7..8aad0bf 100644
--- a/app/resources/resources.cpp
+++ b/app/resources/resources.cpp
@@ -20,24 +20,58 @@ CefRefPtr<CefResourceHandler> BinaryResourceProvider::Create(
     std::string url = request->GetURL();
     Logger::LogMessage("BinaryResourceProvider: Handling URL: " + url);
     
-    // Only handle miko://app requests
-    if (url.find("miko://app") != 0) {
-        Logger::LogMessage("BinaryResourceProvider: URL does not start with miko://app");
+    // Handle miko:// scheme requests
+    if (url.find("miko://") != 0) {
+        Logger::LogMessage("BinaryResourceProvider: URL does not start with miko://");
         return nullptr;
     }
     
-    // Extract the path from the URL (remove "miko://app")
-    std::string path = url.substr(10); // Remove "miko://app"
-    if (path.empty() || path == "/") {
-        path = "/index.html";
+    // Extract the path from the URL (remove "miko://")
+    std::string path = url.substr(7); // Remove "miko://"
+    
+    // Remove query parameters if present
+    size_t query_pos = path.find('?');
+    if (query_pos != std::string::npos) {
+        path = path.substr(0, query_pos);
+    }
+    
+    // Handle different miko:// subdomains
+    if (path.find("app") == 0) {
+        // Remove "app" prefix for legacy support
+        path = path.substr(3);
+        if (path.empty() || path == "/") {
+            path = "/index.html";
+        }
+    } else if (path.find("monaco") == 0) {
+        // Handle monaco subdomain - ensure proper path format
+        if (path.find("monaco/") == 0) {
+            path = "/" + path; // Convert "monaco/index.html" to "/monaco/index.html"
+        } else if (path == "monaco") {
+            path = "/monaco/index.html"; // Default to index.html for bare monaco
+        }
+    } else if (path.find("menuoverlay") == 0) {
+        // Handle menuoverlay subdomain - ensure proper path format
+        if (path.find("menuoverlay/") == 0) {
+            path = "/" + path; // Convert "menuoverlay/index.html" to "/menuoverlay/index.html"
+        } else if (path == "menuoverlay") {
+            path = "/menuoverlay/index.html"; // Default to index.html for bare menuoverlay
+        }
+    } else {
+        // Default handling for other paths
+        if (path.empty() || path == "/") {
+            path = "/index.html";
+        } else if (path[0] != '/') {
+            path = "/" + path;
+        }
     }
     Logger::LogMessage("BinaryResourceProvider: Extracted path: " + path);
     
     // Get resource ID from path
     int resource_id = ResourceUtil::GetResourceId(path);
-    Logger::LogMessage("BinaryResourceProvider: Resource ID: " + std::to_string(resource_id));
+    Logger::LogMessage("BinaryResourceProvider: Resource ID for path '" + path + "': " + std::to_string(resource_id));
     if (resource_id == -1) {
-        Logger::LogMessage("BinaryResourceProvider: Resource not found for path: " + path);
+        Logger::LogMessage("BinaryResourceProvider: ERROR - Resource not found for path: " + path);
+        Logger::LogMessage("BinaryResourceProvider: Available paths: /index.html, /editor.html, /menuoverlay/index.html, /main.css, /main.js");
         return nullptr; // Resource not found
     }
     
diff --git a/app/resources/resourceutil.cpp b/app/resources/resourceutil.cpp
index 9f26241..e69b866 100644
--- a/app/resources/resourceutil.cpp
+++ b/app/resources/resourceutil.cpp
@@ -11,8 +11,8 @@ namespace ResourceUtil {
     // Resource path to ID mapping
     static const std::map<std::string, int> resourceMap = {
         {"/index.html", IDR_HTML_INDEX},
-        {"/editor.html", IDR_HTML_EDITOR},
-        {"/menuoverlay.html", IDR_HTML_MENUOVERLAY},
+        {"/monaco/index.html", IDR_HTML_EDITOR},  // Add monaco subdomain mapping to editor resource
+        {"/menuoverlay/index.html", IDR_HTML_MENUOVERLAY},  // Add menuoverlay subdirectory mapping
         {"/main.css", IDR_CSS_MAIN},
         {"/main.js", IDR_JS_MAIN}
     };
diff --git a/app/webhelper/main.cpp b/app/webhelper/main.cpp
index 8ae1438..84f8abc 100644
--- a/app/webhelper/main.cpp
+++ b/app/webhelper/main.cpp
@@ -15,30 +15,51 @@
 #include "../client/app.hpp"
 #include "../utils/logger.hpp"
 
+// Helper function: detect CEF process type
+std::string GetProcessType(const LPSTR lpCmdLine) {
+    if (!lpCmdLine) return "unknown";
+
+    std::string cmd(lpCmdLine);
+    if (cmd.find("--type=renderer") != std::string::npos) return "renderer";
+    if (cmd.find("--type=gpu-process") != std::string::npos) return "gpu";
+    if (cmd.find("--type=utility") != std::string::npos) return "utility";
+    if (cmd.find("--type=zygote") != std::string::npos) return "zygote";
+    if (cmd.find("--type=broker") != std::string::npos) return "broker";
+    return "browser"; // default / unknown
+}
+
 // WebHelper subprocess entry point
 int WINAPI WinMain(HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR lpCmdLine,
                    int nCmdShow) {
     UNREFERENCED_PARAMETER(hPrevInstance);
-    UNREFERENCED_PARAMETER(lpCmdLine);
     UNREFERENCED_PARAMETER(nCmdShow);
 
-    // Initialize logger for subprocess
     Logger::Initialize();
-    Logger::LogMessage("MikoWebHelper subprocess starting...");
+    Logger::LogMessage("MikoWebHelper starting...");
+
+    std::string procType = GetProcessType(lpCmdLine);
+    Logger::LogMessage("Detected process type: " + procType);
 
     // CEF main args for subprocess
     CefMainArgs main_args(hInstance);
-    
-    // Create CEF app instance
+
+    // Create CEF app instance (same SimpleApp as main)
     CefRefPtr<SimpleApp> app(new SimpleApp);
 
     // Execute the subprocess - this handles renderer, GPU, utility processes
     int exit_code = CefExecuteProcess(main_args, app, nullptr);
-    
-    Logger::LogMessage("MikoWebHelper subprocess exiting with code: " + std::to_string(exit_code));
+
+    if (exit_code >= 0) {
+        // This is a valid CEF child process, exit now
+        Logger::LogMessage("MikoWebHelper subprocess exiting with code: " + std::to_string(exit_code));
+        Logger::Shutdown();
+        return exit_code;
+    }
+
+    // If exit_code == -1 → this is not a CEF subprocess, just exit immediately
+    Logger::LogMessage("MikoWebHelper launched standalone (not a CEF subprocess), exiting.");
     Logger::Shutdown();
-    
-    return exit_code;
-}
\ No newline at end of file
+    return -1;
+}
